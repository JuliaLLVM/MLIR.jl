# partially based on: https://gist.github.com/oxinabox/cdcffc1392f91a2f6d80b2524726d802

const CC = Core.Compiler

function handle_goto(cg, dest, args)
    generate_goto(cg, args, dest; location=IR.Location())
end
function handle_gotoifnot(cg, cond, true_dest, false_dest, true_args, false_args)
    generate_gotoifnot(cg, cond; true_args, false_args, true_dest, false_dest, location=IR.Location())
end 
function handle_gotoifnot(cg, cond::Bool, true_dest, false_dest, true_args, false_args)
    if cond
        handle_goto(cg, true_dest, true_args)
    else
        handle_goto(cg, false_dest, false_args)
    end
end
function handle_phi(cg, T, i)
    T(IR.argument(currentblock(cg), i)) # TODO: flimsy conversion from IR.Value to T. only works if T's constructor can handle this.
end
function handle_return(cg, val::T) where T
    if isnothing(val)
        returnvalues = []
    else
        returnvalues = reinterpret(Tuple{IR.unpack(T)...}, val)
    end
    generate_return(cg, returnvalues; location=IR.Location())
end
function handle_invoke(cg, fname, ret, args...)
    unpacked = []
    for arg in args
        push!(unpacked, reinterpret(Tuple{IR.unpack(typeof(arg))...}, arg)...)
    end
    generate_invoke(cg, fname, ret, unpacked)
end


#Helpers:
"Given some IR generates a MethodInstance suitable for passing to infer_ir!, if you don't already have one with the right argument types"
function get_toplevel_mi_from_ir(ir, _module::Module)
    mi = ccall(:jl_new_method_instance_uninit, Ref{Core.MethodInstance}, ());
    argtypes = map(ir.argtypes) do argtype
        if argtype isa Core.Const
            return argtype.val
        else
            return argtype
        end
    end
    mi.specTypes = Tuple{argtypes...}
    mi.def = _module
    return mi
end

"run type inference and constant propagation on the ir"
function infer_ir!(ir, interp::CC.AbstractInterpreter, mi::CC.MethodInstance)
    method_info = CC.MethodInfo(#=propagate_inbounds=#true, nothing)
    min_world = world = CC.get_world_counter()
    max_world = Base.get_world_counter()
    irsv = CC.IRInterpretationState(interp, method_info, ir, mi, ir.argtypes, world, min_world, max_world)
    rt = CC._ir_abstract_constant_propagation(interp, irsv)
    return ir
end


# add overloads from Core.Compiler into Base
# Diffractor has a bunch of these, we need to make a library for them
# https://github.com/JuliaDiff/Diffractor.jl/blob/b23337a4b12d21104ff237cf0c72bcd2fe13a4f6/src/stage1/hacks.jl
# https://github.com/JuliaDiff/Diffractor.jl/blob/b23337a4b12d21104ff237cf0c72bcd2fe13a4f6/src/stage1/recurse.jl#L238-L247
# https://github.com/JuliaDiff/Diffractor.jl/blob/b23337a4b12d21104ff237cf0c72bcd2fe13a4f6/src/stage1/compiler_utils.jl

Base.iterate(compact::CC.IncrementalCompact, state) = CC.iterate(compact, state)
Base.iterate(compact::CC.IncrementalCompact) = CC.iterate(compact)
Base.getindex(c::CC.IncrementalCompact, args...) = CC.getindex(c, args...)
Base.setindex!(c::CC.IncrementalCompact, args...) = CC.setindex!(c, args...)
Base.setindex!(i::CC.Instruction, args...) = CC.setindex!(i, args...)

function collect_phi_nodes(ir)
    phi_nodes = [Core.PhiNode[] for _ in ir.cfg.blocks]
    for (i, stmt) in enumerate(ir.stmts)
        inst = stmt[:inst]
        if inst isa Core.PhiNode
            push!(
                phi_nodes[CC.block_for_inst(ir.cfg.blocks, i)],
                inst)
        end
    end
    return phi_nodes
end

function get_block_args(phi_nodes, from, to)
    values = []
    for phi in phi_nodes[to]
        i = findfirst(isequal(from), phi.edges)
        val = isnothing(i) ? nothing : phi.values[i]

        push!(values, val)
    end
    return values
end

"""
Transform the IR that was generated by MLIRInterpeter
and wrap the result in an opaque closure that will generate
the MLIR code and return a `IR.Region` when called.

# Example

```julia
cg = ...
blocks = ...
args = ...
ir = first(only(Base.code_ircode(f, types, interp=MLIR.Generate.MLIRInterpreter())))
builder = create_builder!(ir, blocks, cg)
region = builder(args)
```

For a more easy-to-use interface, use methods from `CodegenContext`.
"""
function generate!(cg, ir::CC.IRCode, ret; mi=get_toplevel_mi_from_ir(ir, @__MODULE__))
    original_currentblock = IR.currentblock[]

    reg = IR.Region()

    blocks = [
        prepare_block(ir, bb)
        for bb in ir.cfg.blocks
    ]
    entryblock = first(blocks)

    argtypes = ir.argtypes[begin+1:end] # the first argument is the type of the function itself, we don't need this.
    args = map(enumerate(argtypes)) do (i, argtype)
        temp = []
        for t in IR.unpack(argtype)
            arg = IR.push_argument!(entryblock, IR.Type(t))
            push!(temp, t(arg))
        end
        return reinterpret(argtype, Tuple(temp))
    end

    currentblockindex = 0
    function next_block()
        currentblockindex += 1
        b = blocks[currentblockindex]
        IR.setcurrentblock!(b)
        push!(reg, b)
    end

    transformed_ir = transform(cg, ir, blocks, next_block)
    
    builder! = Core.OpaqueClosure(transformed_ir; do_compile=true)

    builder!(args...)

    argtypes = IR.Type[IR.type(IR.argument(entryblock, i)) for i in 1:IR.nargs(entryblock)]
    rettypes = IR.Type[IR.Type.(IR.unpack(ret))...]
    IR.resetcurrentblock!()
    f_mlir = generate_function(cg, argtypes=>rettypes, reg; name=name(cg, mi))

    IR.setcurrentblock!(original_currentblock) # restore original currentblock (needed for recursion)
    
    return f_mlir
end
generate(cg, ir::CC.IRCode, ret; mi=get_toplevel_mi_from_ir(ir, @__MODULE__)) = generate!(cg, Core.Compiler.copy(ir), ret; mi)
generate(cg, f, types) = generate!(cg, only(Core.Compiler.code_ircode(f, types, interp=MLIRInterpreter()))...)


function get_mi(f, types)
    tt = Base.signature_type(f, types)
    # Find all methods that are applicable to these types
    mthds = Base._methods_by_ftype(tt, -1, Base.get_world_counter())
    if mthds === false || length(mthds) != 1
        error("Unable to find single applicable method for $tt")
    end

    mtypes, msp, m = mthds[1]

    # Grab the appropriate method instance for these types
    mi = Core.Compiler.specialize_method(m, mtypes, msp)
    return mi
end 

function find_invokes(ir)
    callees = Core.MethodInstance[]
    for stmt in ir.stmts
        inst = stmt[:inst]
        if Meta.isexpr(inst, :invoke)
            callee = inst.args[1]
            push!(callees, callee)
        end
    end
    return callees
end

function collect_methods(f, types)
    mi = get_mi(f, types)
    ir, rt = only(Core.Compiler.code_ircode_by_type(mi.specTypes, interp=MLIRInterpreter()))

    worklist = Core.Compiler.IRCode[ir]
    methods = Dict{Core.MethodInstance, Tuple{Core.Compiler.IRCode, Any}}(
        mi => (ir, rt)
    )
    while !isempty(worklist)
        code = pop!(worklist)
        callees = find_invokes(code)
        for callee in callees
            if !haskey(methods, callee) && !is_intrinsic(callee.specTypes)
                ir, rt = only(Core.Compiler.code_ircode_by_type(callee.specTypes, interp=MLIRInterpreter()))
                methods[callee] = (ir, rt)
                push!(worklist, ir)
            end
        end
    end

    return methods
end
    

function transform(cg, ir, blocks, next_block)
    # insert calls to next_block at the beginning of each block and add explicit gotos if they are missing.
    #   first block is handled separately:
    CC.insert_node!(
        ir,
        CC.SSAValue(1),
        CC.NewInstruction(
            Expr(:call, next_block),
            Any,
            CC.NoCallInfo(),
            Int32(1),
            CC.IR_FLAG_REFINED
        )
    )
    # remainder of the blocks:
    for i in ir.cfg.index
        CC.insert_node!(
            ir,
            i,
            CC.NewInstruction(
                Expr(:call, next_block),
                Any,
                CC.NoCallInfo(),
                Int32(1),
                CC.IR_FLAG_REFINED
            )
        )
        if !(ir.stmts[i-1][:inst] isa Union{Core.GotoIfNot, Core.GotoNode, Core.ReturnNode})
            CC.insert_node!(
                ir,
                CC.SSAValue(i-1),
                CC.NewInstruction(
                    Core.GotoNode(CC.block_for_inst(ir.cfg.blocks, i)),
                    Any,
                    CC.NoCallInfo(),
                    Int32(1),
                    CC.IR_FLAG_REFINED
                ),
                true
            )
        end      
    end

    phi_nodes = collect_phi_nodes(ir)
    compact = CC.IncrementalCompact(ir, #=allow_cfg_transforms=# true)

    prev_bb = compact.active_bb
    current_phi = 1

    # Core of the transformation:
    # replace GotoIfNot, GotoNode, PhiNode, ReturnNode with calls to MLIR generation functions.
    for ((original_idx, idx), inst) in compact
        ssa = Core.SSAValue(idx)
    
        if inst isa Union{Core.GotoIfNot, Core.GotoNode, Core.PhiNode, Core.ReturnNode}
            if inst isa Core.GotoIfNot
                compact[ssa][:inst] = Expr(:call, Core.tuple, get_block_args(phi_nodes, compact.active_bb-1, inst.dest)...)
                
                false_dest = inst.dest
                true_dest = compact.active_bb
                
                false_args = ssa
                # when cond is true, branch to next block
                true_args = Core.Compiler.insert_node_here!(
                    compact,
                    Core.Compiler.NewInstruction(
                        Expr(:call, Core.tuple, get_block_args(phi_nodes, compact.active_bb-1, compact.active_bb)...),
                        Any,
                        Core.Compiler.NoCallInfo(),
                        Int32(1),
                        Core.Compiler.IR_FLAG_REFINED
                    ),
                    true
                )
                Core.Compiler.insert_node_here!(
                    compact,
                    Core.Compiler.NewInstruction(
                        Expr(:call, handle_gotoifnot, cg, inst.cond, blocks[true_dest], blocks[false_dest], true_args, false_args),
                        Any,
                        Core.Compiler.NoCallInfo(),
                        Int32(1),
                        Core.Compiler.IR_FLAG_REFINED
                    ),
                    true # insert within the current basic block, not at the start of the next one
                )    
            elseif inst isa Core.GotoNode
                compact[ssa][:inst] = Expr(:call, Core.tuple, get_block_args(phi_nodes, compact.active_bb-1, inst.label)...)
                Core.Compiler.insert_node_here!(
                    compact,
                    Core.Compiler.NewInstruction(
                        Expr(:call, handle_goto, cg, blocks[inst.label], ssa),
                        Any,
                        Core.Compiler.NoCallInfo(),
                        Int32(1),
                        Core.Compiler.IR_FLAG_REFINED
                    ),
                    true
                )
            elseif inst isa Core.PhiNode
                # determine how many phi nodes came before within this block. 
                if prev_bb == compact.active_bb
                    current_phi += 1
                else
                    current_phi = 1
                    prev_bb = compact.active_bb
                end
    
                compact[ssa][:inst] = Expr(:call, handle_phi, cg, compact[ssa][:type], current_phi)
            elseif inst isa Core.ReturnNode
                if isdefined(inst, :val)
                    compact[ssa][:inst] = Expr(:call, handle_return, cg, inst.val)
                else
                    compact[ssa][:inst] = :nothing
                end
            end

            # Set general type Any and set flag to allow re-inferring type.
            compact[ssa][:type] = Any
            compact[ssa][:flag] = CC.IR_FLAG_REFINED
        elseif Meta.isexpr(inst, :invoke)
            mi, called_func, args... = inst.args
            if called_func == bool_conversion_intrinsic
                compact[ssa][:inst] = only(args)
            elseif !is_intrinsic(mi.specTypes)
                fname = name(cg, mi)
                compact[ssa][:inst] = Expr(:call, handle_invoke, cg, fname, compact[ssa][:type], args...)
                compact[ssa][:type] = Any
            end
        end
    end

    # Since ReturnNodes have disappeared, add an explicit `return nothing` at the end.
    CC.insert_node_here!(
        compact,
        CC.NewInstruction(
            Core.ReturnNode(nothing),
            Nothing,
            Int32(1)
        ))
    
    ir = CC.finish(compact)
    
    # manually set CFG to be a straight line.
    # TODO: there might be a better way to do this
    for (i, b) in enumerate(ir.cfg.blocks)
        deleteat!(b.preds, 1:length(b.preds))
        deleteat!(b.succs, 1:length(b.succs))
        insert!(b.preds, 1, i-1)
        insert!(b.succs, 1, i+1)
    end
    deleteat!(ir.cfg.blocks[1].preds, 1:length(ir.cfg.blocks[1].preds))
    deleteat!(ir.cfg.blocks[end].succs, 1:length(ir.cfg.blocks[end].succs))
    
    ir = CC.compact!(ir)
    
    # type inference
    interp = CC.NativeInterpreter()
    mi = get_toplevel_mi_from_ir(ir, @__MODULE__);
    ir = infer_ir!(ir, interp, mi)

    # inlining
    inline_state = CC.InliningState(interp)
    ir = CC.ssa_inlining_pass!(ir, inline_state, #=propagate_inbounds=#true)
    ir = CC.compact!(ir)

    # SROA + DCE
    ir = CC.sroa_pass!(ir, inline_state)
    ir = first(CC.adce_pass!(ir, inline_state))
    ir = CC.compact!(ir)

    # errors if invalid
    CC.verify_ir(ir)

    return ir
end

"Generates a block argument for each phi node present in the block."
function prepare_block(ir, bb)
    b = IR.Block()

    for sidx in bb.stmts
        stmt = ir.stmts[sidx]
        inst = stmt[:inst]
        inst isa Core.PhiNode || continue

        type = stmt[:type]
        IR.push_argument!(b, IR.Type(type))
    end

    return b
end