using Test
@warn "Running MLIR code generation tests. This can take a few minutes."

# include type and intrinsic function definitions:
include("definitions.jl");

import MLIR: IR, Generate, Dialects, API
import MLIR.IR: Value, Operation, result, Convertible, context, ValueTrait

# administrative duties
function registerAllDialects!()
    ctx = IR.context()
    registry = API.mlirDialectRegistryCreate()
    API.mlirRegisterAllDialects(registry)
    API.mlirContextAppendDialectRegistry(ctx, registry)
    API.mlirDialectRegistryDestroy(registry)

    API.mlirContextLoadAllAvailableDialects(ctx)
    return registry
end
ctx = IR.Context()
registerAllDialects!();
API.mlirRegisterAllPasses()
API.mlirRegisterAllLLVMTranslations(ctx.context)

function compare_generated(op::IR.Operation, expected::String)
    op = Base.copy(op) # don't mutate the original
    mod = IR.Module()
    push!(IR.body(mod), op)
    generated = string(mod)
    expected = string(parse(IR.Module, expected))
    return generated == expected
end

# A codegen context is used to specify how Julia IR is converted to MLIR.
cg = Generate.CodegenContext()

op1 = cg(Tuple{i64,i64}) do a, b
    a + b
end

@test compare_generated(
    op1,
    """
func.func @f(%a: i64, %b: i64) -> i64 {
    %sum = arith.addi %a, %b : i64
    return %sum : i64
}
""",
)

# isbitstype structs can be used as arguments or return types.
# They will be unpacked into their constituent fields that are convertible to MLIR types.
# e.g. a function `Point{i64}` taking and returning a point, will be converted to a MLIR
# function that takes two `i64` arguments and returns two `i64` values.
struct Point{T}
    x::T
    y::T
end

struct Line{T}
    p1::Point{T}
    p2::Point{T}
end

sq_distance(l::Line) = (l.p1.x - l.p2.x)^2 + (l.p1.y - l.p2.y)^2

op2 = cg(Tuple{Point{i64},Point{i64}}) do a, b
    l = Line(a, b)
    d_2 = sq_distance(l)

    Point(((a.x, a.y) .- d_2)...)
end

# Note the large number of basic blocks generated.
# Simplification passes in MLIR can be used to clean these up.
@test compare_generated(
    op2,
    """
func.func @f(%arg0: i64, %arg1: i64, %arg2: i64, %arg3: i64) -> (i64, i64) {
  %0 = arith.subi %arg0, %arg2 : i64
  %1 = arith.muli %0, %0 : i64
  %2 = arith.subi %arg1, %arg3 : i64
  %3 = arith.muli %2, %2 : i64
  %4 = arith.addi %1, %3 : i64
  cf.br ^bb1
^bb1:  // pred: ^bb0
  cf.br ^bb2
^bb2:  // pred: ^bb1
  cf.br ^bb3
^bb3:  // pred: ^bb2
  cf.br ^bb4
^bb4:  // pred: ^bb3
  cf.br ^bb5
^bb5:  // pred: ^bb4
  %5 = arith.subi %arg0, %4 : i64
  cf.br ^bb6
^bb6:  // pred: ^bb5
  cf.br ^bb7
^bb7:  // pred: ^bb6
  cf.br ^bb8
^bb8:  // pred: ^bb7
  cf.br ^bb9
^bb9:  // pred: ^bb8
  cf.br ^bb10
^bb10:  // pred: ^bb9
  cf.br ^bb11
^bb11:  // pred: ^bb10
  cf.br ^bb12
^bb12:  // pred: ^bb11
  %6 = arith.subi %arg1, %4 : i64
  cf.br ^bb13
^bb13:  // pred: ^bb12
  cf.br ^bb14
^bb14:  // pred: ^bb13
  cf.br ^bb15
^bb15:  // pred: ^bb14
  cf.br ^bb16
^bb16:  // pred: ^bb15
  cf.br ^bb17
^bb17:  // pred: ^bb16
  return %5, %6 : i64, i64
}
""",
)

# To customize how goto's or return statements are converted to MLIR, we can specialize
# particular methods for a new type.
# In this case, we create a codegen context that will generate `scf.yield` for return
# statements in Julia SSA IR.
# We also change the behaviour of `generate_function` to return the generated region
# instead of wrapping it in a `func.func` operation, as we want to nest it inside a
# `scf.for` operation.
import MLIR.Generate: generate_return, generate_function
abstract type LoopBody end
function generate_return(cg::Generate.CodegenContext{LoopBody}, values; location)
    return Dialects.scf.yield(values)
end
generate_function(cg::Generate.CodegenContext{LoopBody}, argtypes, rettypes, reg) = reg

# This intrinsic function creates an operation containing a region.
# The region body is generated by the `body` function, which is passed the intrinsic function
# as an argument.
Generate.@intrinsic function scf_for(
    body, initial_value::T, start::index, stop::index, step::index
) where {T}
    region = Generate.CodegenContext{LoopBody}()(body, Tuple{index,T})
    op = Dialects.scf.for_(
        start, stop, step, [initial_value]; results_=IR.Type[IR.Type(T)], region
    )
    return T(IR.result(op))
end

function g(N)
    val = i64(0)
    scf_for(val, index(0), N, index(1)) do i, val
        val + i64(i)
    end
end

op3 = cg(g, Tuple{index})

@test compare_generated(op3, """
func.func @f(%N: index) -> i64 {
  %val = arith.constant 0 : i64
  %idx0 = index.constant 0
  %idx1 = index.constant 1
  %0 = scf.for %i = %idx0 to %N step %idx1 iter_args(%val_capt = %val) -> (i64) {
    %i_cast = index.casts %i : index to i64
    %2 = arith.addi %val_capt, %i_cast : i64
    scf.yield %2 : i64
  }
  return %0 : i64
}
""")
