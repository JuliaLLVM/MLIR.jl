var documenterSearchIndex = {"docs":
[{"location":"dialects/quant/#quant-dialect","page":"quant","title":"quant dialect","text":"","category":"section"},{"location":"dialects/quant/","page":"quant","title":"quant","text":"Modules = [MLIR.Dialects.quant]\nPages = [\"Dialects/15/Quant.jl\"]","category":"page"},{"location":"dialects/linalg/#linalg-dialect","page":"linalg","title":"linalg dialect","text":"","category":"section"},{"location":"dialects/linalg/","page":"linalg","title":"linalg","text":"Modules = [MLIR.Dialects.linalg]\nPages = [\"Dialects/15/Linalg.jl\"]","category":"page"},{"location":"IR/location/#Location","page":"Location","title":"Location","text":"","category":"section"},{"location":"IR/location/","page":"Location","title":"Location","text":"Modules = [MLIR.IR]\nPages = [\"IR/Location.jl\"]","category":"page"},{"location":"IR/typeid/#TypeID","page":"TypeID","title":"TypeID","text":"","category":"section"},{"location":"IR/typeid/","page":"TypeID","title":"TypeID","text":"Modules = [MLIR.IR]\nPages = [\"IR/TypeID.jl\"]","category":"page"},{"location":"IR/typeid/#Base.:==-Tuple{MLIR.IR.TypeID, MLIR.IR.TypeID}","page":"TypeID","title":"Base.:==","text":"==(typeID1, typeID2)\n\nChecks if two type ids are equal.\n\n\n\n\n\n","category":"method"},{"location":"IR/typeid/#Base.hash-Tuple{MLIR.IR.TypeID}","page":"TypeID","title":"Base.hash","text":"hash(typeID)\n\nReturns the hash value of the type id.\n\n\n\n\n\n","category":"method"},{"location":"IR/integerset/#Integer-Set","page":"IntegerSet","title":"Integer Set","text":"","category":"section"},{"location":"IR/integerset/","page":"IntegerSet","title":"IntegerSet","text":"Modules = [MLIR.IR]\nPages = [\"IR/IntegerSet.jl\"]","category":"page"},{"location":"IR/integerset/#MLIR.IR.IntegerSet-NTuple{4, Any}","page":"IntegerSet","title":"MLIR.IR.IntegerSet","text":"IntegerSet(ndims, nsymbols, constraints, eqflags; context=context())\n\nGets or creates a new integer set in the given context. The set is defined by a list of affine constraints, with the given number of input dimensions and symbols, which are treated as either equalities (eqflags is 1) or inequalities (eqflags is 0). Both constraints and eqflags need to be arrays of the same length.\n\n\n\n\n\n","category":"method"},{"location":"IR/integerset/#MLIR.IR.IntegerSet-Tuple{Any, Any}","page":"IntegerSet","title":"MLIR.IR.IntegerSet","text":"Integerset(ndims, nsymbols; context=context())\n\nGets or creates a new canonically empty integer set with the give number of dimensions and symbols in the given context.\n\n\n\n\n\n","category":"method"},{"location":"IR/integerset/#Base.:==-Tuple{MLIR.IR.IntegerSet, MLIR.IR.IntegerSet}","page":"IntegerSet","title":"Base.:==","text":"==(s1, s2)\n\nChecks if two integer set objects are equal. This is a \"shallow\" comparison of two objects. Only the sets with some small number of constraints are uniqued and compare equal here. Set objects that represent the same integer set with different constraints may be considered non-equal by this check. Set difference followed by an (expensive) emptiness check should be used to check equivalence of the underlying integer sets.\n\n\n\n\n\n","category":"method"},{"location":"IR/integerset/#Base.ndims-Tuple{MLIR.IR.IntegerSet}","page":"IntegerSet","title":"Base.ndims","text":"ndims(set)\n\nReturns the number of dimensions in the given set.\n\n\n\n\n\n","category":"method"},{"location":"IR/integerset/#Base.replace-Tuple{MLIR.IR.IntegerSet, Any, Any}","page":"IntegerSet","title":"Base.replace","text":"mlirIntegerSetReplaceGet(set, dimReplacements, symbolReplacements, numResultDims, numResultSymbols)\n\nGets or creates a new integer set in which the values and dimensions of the given set are replaced with the given affine expressions. dimReplacements and symbolReplacements are expected to point to at least as many consecutive expressions as the given set has dimensions and symbols, respectively. The new set will have numResultDims and numResultSymbols dimensions and symbols, respectively.\n\n\n\n\n\n","category":"method"},{"location":"IR/integerset/#MLIR.IR.constraint-Tuple{MLIR.IR.IntegerSet, Any}","page":"IntegerSet","title":"MLIR.IR.constraint","text":"mlirIntegerSetGetConstraint(set, i)\n\nReturns i-th constraint of the set.\n\n\n\n\n\n","category":"method"},{"location":"IR/integerset/#MLIR.IR.context-Tuple{MLIR.IR.IntegerSet}","page":"IntegerSet","title":"MLIR.IR.context","text":"context(set)\n\nGets the context in which the given integer set lives.\n\n\n\n\n\n","category":"method"},{"location":"IR/integerset/#MLIR.IR.isconstrainteq-Tuple{MLIR.IR.IntegerSet, Any}","page":"IntegerSet","title":"MLIR.IR.isconstrainteq","text":"mlirIntegerSetIsConstraintEq(set, i)\n\nReturns true of the i-th constraint of the set is an equality constraint, false otherwise.\n\n\n\n\n\n","category":"method"},{"location":"IR/integerset/#MLIR.IR.isempty-Tuple{MLIR.IR.IntegerSet}","page":"IntegerSet","title":"MLIR.IR.isempty","text":"isempty(set)\n\nChecks whether the given set is a canonical empty set, e.g., the set returned by mlirIntegerSetEmptyGet.\n\n\n\n\n\n","category":"method"},{"location":"IR/integerset/#MLIR.IR.nconstraints-Tuple{MLIR.IR.IntegerSet}","page":"IntegerSet","title":"MLIR.IR.nconstraints","text":"nconstraints(set)\n\nReturns the number of constraints (equalities + inequalities) in the given set.\n\n\n\n\n\n","category":"method"},{"location":"IR/integerset/#MLIR.IR.nequalities-Tuple{MLIR.IR.IntegerSet}","page":"IntegerSet","title":"MLIR.IR.nequalities","text":"nequalities(set)\n\nReturns the number of equalities in the given set.\n\n\n\n\n\n","category":"method"},{"location":"IR/integerset/#MLIR.IR.ninequalities-Tuple{MLIR.IR.IntegerSet}","page":"IntegerSet","title":"MLIR.IR.ninequalities","text":"ninequalities(set)\n\nReturns the number of inequalities in the given set.\n\n\n\n\n\n","category":"method"},{"location":"IR/integerset/#MLIR.IR.ninputs-Tuple{MLIR.IR.IntegerSet}","page":"IntegerSet","title":"MLIR.IR.ninputs","text":"ninputs(set)\n\nReturns the number of inputs (dimensions + symbols) in the given set.\n\n\n\n\n\n","category":"method"},{"location":"IR/integerset/#MLIR.IR.nsymbols-Tuple{MLIR.IR.IntegerSet}","page":"IntegerSet","title":"MLIR.IR.nsymbols","text":"nsymbols(set)\n\nReturns the number of symbols in the given set.\n\n\n\n\n\n","category":"method"},{"location":"dialects/pdl_interp/#pdl_interp-dialect","page":"pdl_interp","title":"pdl_interp dialect","text":"","category":"section"},{"location":"dialects/pdl_interp/","page":"pdl_interp","title":"pdl_interp","text":"Modules = [MLIR.Dialects.pdl_interp]\nPages = [\"Dialects/15/PDLInterp.jl\"]","category":"page"},{"location":"IR/operation/#Operation","page":"Operation","title":"Operation","text":"","category":"section"},{"location":"IR/operation/","page":"Operation","title":"Operation","text":"Modules = [MLIR.IR]\nPages = [\"IR/Operation.jl\"]","category":"page"},{"location":"IR/operation/#Base.copy-Tuple{MLIR.IR.Operation}","page":"Operation","title":"Base.copy","text":"copy(op)\n\nCreates a deep copy of an operation. The operation is not inserted and ownership is transferred to the caller.\n\n\n\n\n\n","category":"method"},{"location":"IR/operation/#MLIR.IR.attr!-Tuple{MLIR.IR.Operation, Any, Any}","page":"Operation","title":"MLIR.IR.attr!","text":"attr!(op, name, attr)\n\nSets an attribute by name, replacing the existing if it exists or adding a new one otherwise.\n\n\n\n\n\n","category":"method"},{"location":"IR/operation/#MLIR.IR.attr-Tuple{MLIR.IR.Operation, AbstractString}","page":"Operation","title":"MLIR.IR.attr","text":"attr(op, name)\n\nReturns an attribute attached to the operation given its name.\n\n\n\n\n\n","category":"method"},{"location":"IR/operation/#MLIR.IR.attr-Tuple{MLIR.IR.Operation, Any}","page":"Operation","title":"MLIR.IR.attr","text":"attr(op, i)\n\nReturn i-th attribute of the operation.\n\n\n\n\n\n","category":"method"},{"location":"IR/operation/#MLIR.IR.block-Tuple{MLIR.IR.Operation}","page":"Operation","title":"MLIR.IR.block","text":"block(op)\n\nGets the block that owns this operation, returning null if the operation is not owned.\n\n\n\n\n\n","category":"method"},{"location":"IR/operation/#MLIR.IR.context-Tuple{MLIR.IR.Operation}","page":"Operation","title":"MLIR.IR.context","text":"context(op)\n\nGets the context this operation is associated with.\n\n\n\n\n\n","category":"method"},{"location":"IR/operation/#MLIR.IR.is_registered-Tuple{Any}","page":"Operation","title":"MLIR.IR.is_registered","text":"is_registered(name; context=context())\n\nReturns whether the given fully-qualified operation (i.e. 'dialect.operation') is registered with the context. This will return true if the dialect is loaded and the operation is registered within the dialect.\n\n\n\n\n\n","category":"method"},{"location":"IR/operation/#MLIR.IR.location-Tuple{MLIR.IR.Operation}","page":"Operation","title":"MLIR.IR.location","text":"location(op)\n\nGets the location of the operation.\n\n\n\n\n\n","category":"method"},{"location":"IR/operation/#MLIR.IR.move_after!-Tuple{MLIR.IR.Operation, MLIR.IR.Operation}","page":"Operation","title":"MLIR.IR.move_after!","text":"move_after!(op, other)\n\nMoves the given operation immediately after the other operation in its parent block. The given operation may be owned by the caller or by its current block. The other operation must belong to a block. In any case, the ownership is transferred to the block of the other operation.\n\n\n\n\n\n","category":"method"},{"location":"IR/operation/#MLIR.IR.move_before!-Tuple{MLIR.IR.Operation, MLIR.IR.Operation}","page":"Operation","title":"MLIR.IR.move_before!","text":"move_before!(op, other)\n\nMoves the given operation immediately before the other operation in its parent block. The given operation may be owner by the caller or by its current block. The other operation must belong to a block. In any case, the ownership is transferred to the block of the other operation.\n\n\n\n\n\n","category":"method"},{"location":"IR/operation/#MLIR.IR.name-Tuple{MLIR.IR.Operation}","page":"Operation","title":"MLIR.IR.name","text":"name(op)\n\nGets the name of the operation as an identifier.\n\n\n\n\n\n","category":"method"},{"location":"IR/operation/#MLIR.IR.nattrs-Tuple{MLIR.IR.Operation}","page":"Operation","title":"MLIR.IR.nattrs","text":"nattrs(op)\n\nReturns the number of attributes attached to the operation.\n\n\n\n\n\n","category":"method"},{"location":"IR/operation/#MLIR.IR.noperands-Tuple{MLIR.IR.Operation}","page":"Operation","title":"MLIR.IR.noperands","text":"noperands(op)\n\nReturns the number of operands of the operation.\n\n\n\n\n\n","category":"method"},{"location":"IR/operation/#MLIR.IR.nregions-Tuple{MLIR.IR.Operation}","page":"Operation","title":"MLIR.IR.nregions","text":"nregions(op)\n\nReturns the number of regions attached to the given operation.\n\n\n\n\n\n","category":"method"},{"location":"IR/operation/#MLIR.IR.nresults-Tuple{MLIR.IR.Operation}","page":"Operation","title":"MLIR.IR.nresults","text":"nresults(op)\n\nReturns the number of results of the operation.\n\n\n\n\n\n","category":"method"},{"location":"IR/operation/#MLIR.IR.nsuccessors-Tuple{MLIR.IR.Operation}","page":"Operation","title":"MLIR.IR.nsuccessors","text":"nsuccessors(op)\n\nReturns the number of successor blocks of the operation.\n\n\n\n\n\n","category":"method"},{"location":"IR/operation/#MLIR.IR.operand","page":"Operation","title":"MLIR.IR.operand","text":"operand(op, i)\n\nReturns i-th operand of the operation.\n\n\n\n\n\n","category":"function"},{"location":"IR/operation/#MLIR.IR.operand!-Tuple{MLIR.IR.Operation, Any, Any}","page":"Operation","title":"MLIR.IR.operand!","text":"operand!(op, i, value)\n\nSets the i-th operand of the operation.\n\n\n\n\n\n","category":"method"},{"location":"IR/operation/#MLIR.IR.parent_op-Tuple{MLIR.IR.Operation}","page":"Operation","title":"MLIR.IR.parent_op","text":"parent_op(op)\n\nGets the operation that owns this operation, returning null if the operation is not owned.\n\n\n\n\n\n","category":"method"},{"location":"IR/operation/#MLIR.IR.region-Tuple{MLIR.IR.Operation, Any}","page":"Operation","title":"MLIR.IR.region","text":"region(op, i)\n\nReturns i-th region attached to the operation.\n\n\n\n\n\n","category":"method"},{"location":"IR/operation/#MLIR.IR.result","page":"Operation","title":"MLIR.IR.result","text":"result(op, i)\n\nReturns i-th result of the operation.\n\n\n\n\n\n","category":"function"},{"location":"IR/operation/#MLIR.IR.rmattr!-Tuple{MLIR.IR.Operation, Any}","page":"Operation","title":"MLIR.IR.rmattr!","text":"rmattr!(op, name)\n\nRemoves an attribute by name. Returns false if the attribute was not found and true if removed.\n\n\n\n\n\n","category":"method"},{"location":"IR/operation/#MLIR.IR.rmfromparent!-Tuple{MLIR.IR.Operation}","page":"Operation","title":"MLIR.IR.rmfromparent!","text":"rmfromparent(op)\n\nRemoves the given operation from its parent block. The operation is not destroyed. The ownership of the operation is transferred to the caller.\n\n\n\n\n\n","category":"method"},{"location":"IR/operation/#MLIR.IR.successor-Tuple{MLIR.IR.Operation, Any}","page":"Operation","title":"MLIR.IR.successor","text":"successor(op, i)\n\nReturns i-th successor of the operation.\n\n\n\n\n\n","category":"method"},{"location":"IR/operation/#MLIR.IR.typeid-Tuple{MLIR.IR.Operation}","page":"Operation","title":"MLIR.IR.typeid","text":"typeid(op)\n\nGets the type id of the operation. Returns null if the operation does not have a registered operation description.\n\n\n\n\n\n","category":"method"},{"location":"IR/operation/#MLIR.IR.verify-Tuple{MLIR.IR.Operation}","page":"Operation","title":"MLIR.IR.verify","text":"verify(op)\n\nVerify the operation and return true if it passes, false if it fails.\n\n\n\n\n\n","category":"method"},{"location":"dialects/emitc/#emitc-dialect","page":"emitc","title":"emitc dialect","text":"","category":"section"},{"location":"dialects/emitc/","page":"emitc","title":"emitc","text":"Modules = [MLIR.Dialects.emitc]\nPages = [\"Dialects/15/EmitC.jl\"]","category":"page"},{"location":"IR/value/#Value","page":"Value","title":"Value","text":"","category":"section"},{"location":"IR/value/","page":"Value","title":"Value","text":"Modules = [MLIR.IR]\nPages = [\"IR/Value.jl\"]","category":"page"},{"location":"IR/value/#Base.:==-Tuple{MLIR.IR.Value, MLIR.IR.Value}","page":"Value","title":"Base.:==","text":"==(value1, value2)\n\nReturns 1 if two values are equal, 0 otherwise.\n\n\n\n\n\n","category":"method"},{"location":"IR/value/#MLIR.IR.block_arg_num-Tuple{MLIR.IR.Value}","page":"Value","title":"MLIR.IR.block_arg_num","text":"block_arg_num(value)\n\nReturns the position of the value in the argument list of its block.\n\n\n\n\n\n","category":"method"},{"location":"IR/value/#MLIR.IR.block_owner-Tuple{MLIR.IR.Value}","page":"Value","title":"MLIR.IR.block_owner","text":"block_owner(value)\n\nReturns the block in which this value is defined as an argument. Asserts if the value is not a block argument.\n\n\n\n\n\n","category":"method"},{"location":"IR/value/#MLIR.IR.is_block_arg-Tuple{MLIR.IR.Value}","page":"Value","title":"MLIR.IR.is_block_arg","text":"is_block_arg(value)\n\nReturns 1 if the value is a block argument, 0 otherwise.\n\n\n\n\n\n","category":"method"},{"location":"IR/value/#MLIR.IR.is_op_res-Tuple{MLIR.IR.Value}","page":"Value","title":"MLIR.IR.is_op_res","text":"is_op_res(value)\n\nReturns 1 if the value is an operation result, 0 otherwise.\n\n\n\n\n\n","category":"method"},{"location":"IR/value/#MLIR.IR.op_owner-Tuple{MLIR.IR.Value}","page":"Value","title":"MLIR.IR.op_owner","text":"op_owner(value)\n\nReturns an operation that produced this value as its result. Asserts if the value is not an op result.\n\n\n\n\n\n","category":"method"},{"location":"IR/value/#MLIR.IR.op_res_num-Tuple{MLIR.IR.Value}","page":"Value","title":"MLIR.IR.op_res_num","text":"op_res_num(value)\n\nReturns the position of the value in the list of results of the operation that produced it.\n\n\n\n\n\n","category":"method"},{"location":"IR/value/#MLIR.IR.type!-Tuple{Any, Any}","page":"Value","title":"MLIR.IR.type!","text":"set_type!(value, type)\n\nSets the type of the block argument to the given type.\n\n\n\n\n\n","category":"method"},{"location":"IR/value/#MLIR.IR.type-Tuple{MLIR.IR.Value}","page":"Value","title":"MLIR.IR.type","text":"type(value)\n\nReturns the type of the value.\n\n\n\n\n\n","category":"method"},{"location":"dialects/gpu/#gpu-dialect","page":"gpu","title":"gpu dialect","text":"","category":"section"},{"location":"dialects/gpu/","page":"gpu","title":"gpu","text":"Modules = [MLIR.Dialects.gpu]\nPages = [\"Dialects/15/GPU.jl\"]","category":"page"},{"location":"dialects/tensor/#tensor-dialect","page":"tensor","title":"tensor dialect","text":"","category":"section"},{"location":"dialects/tensor/","page":"tensor","title":"tensor","text":"Modules = [MLIR.Dialects.tensor]\nPages = [\"Dialects/15/Tensor.jl\"]","category":"page"},{"location":"dialects/amdgpu/#amdgpu-dialect","page":"amdgpu","title":"amdgpu dialect","text":"","category":"section"},{"location":"dialects/amdgpu/","page":"amdgpu","title":"amdgpu","text":"Modules = [MLIR.Dialects.amdgpu]\nPages = [\"Dialects/15/AMDGPU.jl\"]","category":"page"},{"location":"dialects/spirv/#spv-dialect","page":"spv","title":"spv dialect","text":"","category":"section"},{"location":"dialects/spirv/","page":"spv","title":"spv","text":"Modules = [MLIR.Dialects.spv]\nPages = [\"Dialects/15/SPIRV.jl\"]","category":"page"},{"location":"dialects/openacc/#acc-dialect","page":"openacc","title":"acc dialect","text":"","category":"section"},{"location":"dialects/openacc/","page":"openacc","title":"openacc","text":"Modules = [MLIR.Dialects.acc]\nPages = [\"Dialects/15/OpenACC.jl\"]","category":"page"},{"location":"dialects/builtin/#builtin-dialect","page":"builtin","title":"builtin dialect","text":"","category":"section"},{"location":"dialects/builtin/","page":"builtin","title":"builtin","text":"Modules = [MLIR.Dialects.builtin]\nPages = [\"Dialects/15/Builtin.jl\"]","category":"page"},{"location":"dialects/shape/#shape-dialect","page":"shape","title":"shape dialect","text":"","category":"section"},{"location":"dialects/shape/","page":"shape","title":"shape","text":"Modules = [MLIR.Dialects.shape]\nPages = [\"Dialects/15/Shape.jl\"]","category":"page"},{"location":"dialects/controlflow/#cf-dialect","page":"cf","title":"cf dialect","text":"","category":"section"},{"location":"dialects/controlflow/","page":"cf","title":"cf","text":"Modules = [MLIR.Dialects.cf]\nPages = [\"Dialects/15/ControlFlow.jl\"]","category":"page"},{"location":"IR/context/#Context","page":"Context","title":"Context","text":"","category":"section"},{"location":"IR/context/","page":"Context","title":"Context","text":"Modules = [MLIR.IR]\nPages = [\"IR/Context.jl\"]","category":"page"},{"location":"IR/context/#MLIR.IR.Context-Tuple{}","page":"Context","title":"MLIR.IR.Context","text":"Context()\n\nCreates an MLIR context and transfers its ownership to the caller.\n\n\n\n\n\n","category":"method"},{"location":"IR/attribute/#Attribute","page":"Attribute","title":"Attribute","text":"","category":"section"},{"location":"IR/attribute/","page":"Attribute","title":"Attribute","text":"Modules = [MLIR.IR]\nPages = [\"IR/Attribute.jl\"]","category":"page"},{"location":"IR/attribute/#Core.Bool-Tuple{MLIR.IR.Attribute}","page":"Attribute","title":"Core.Bool","text":"Bool(attr)\n\nReturns the value stored in the given bool attribute.\n\n\n\n\n\n","category":"method"},{"location":"IR/attribute/#Core.Float64-Tuple{MLIR.IR.Attribute}","page":"Attribute","title":"Core.Float64","text":"Float64(attr)\n\nReturns the value stored in the given floating point attribute, interpreting the value as double.\n\n\n\n\n\n","category":"method"},{"location":"IR/attribute/#Core.Int64-Tuple{MLIR.IR.Attribute}","page":"Attribute","title":"Core.Int64","text":"Int64(attr)\n\nReturns the value stored in the given integer attribute, assuming the value is of signed type and fits into a signed 64-bit integer.\n\n\n\n\n\n","category":"method"},{"location":"IR/attribute/#Core.String-Tuple{MLIR.IR.Attribute}","page":"Attribute","title":"Core.String","text":"String(attr)\n\nReturns the attribute values as a string reference. The data remains live as long as the context in which the attribute lives.\n\n\n\n\n\n","category":"method"},{"location":"IR/attribute/#Core.UInt64-Tuple{MLIR.IR.Attribute}","page":"Attribute","title":"Core.UInt64","text":"UInt64(attr)\n\nReturns the value stored in the given integer attribute, assuming the value is of unsigned type and fits into an unsigned 64-bit integer.\n\n\n\n\n\n","category":"method"},{"location":"IR/attribute/#MLIR.IR.AffineMap-Tuple{MLIR.IR.Attribute}","page":"Attribute","title":"MLIR.IR.AffineMap","text":"AffineMap(attr)\n\nReturns the affine map wrapped in the given affine map attribute.\n\n\n\n\n\n","category":"method"},{"location":"IR/attribute/#MLIR.IR.Attribute-Tuple{AbstractString}","page":"Attribute","title":"MLIR.IR.Attribute","text":"Attribute(str; context=context())\n\nCreates a string attribute in the given context containing the given string.\n\n\n\n\n\n","category":"method"},{"location":"IR/attribute/#MLIR.IR.Attribute-Tuple{Bool}","page":"Attribute","title":"MLIR.IR.Attribute","text":"Attribute(value; context=context())\n\nCreates a bool attribute in the given context with the given value.\n\n\n\n\n\n","category":"method"},{"location":"IR/attribute/#MLIR.IR.Attribute-Tuple{Dict}","page":"Attribute","title":"MLIR.IR.Attribute","text":"Attribute(elements; context=context())\n\nCreates a dictionary attribute containing the given list of elements in the provided context.\n\n\n\n\n\n","category":"method"},{"location":"IR/attribute/#MLIR.IR.Attribute-Tuple{MLIR.IR.AffineMap}","page":"Attribute","title":"MLIR.IR.Attribute","text":"Attribute(affineMap)\n\nCreates an affine map attribute wrapping the given map. The attribute belongs to the same context as the affine map.\n\n\n\n\n\n","category":"method"},{"location":"IR/attribute/#MLIR.IR.Attribute-Tuple{MLIR.IR.Type, AbstractString}","page":"Attribute","title":"MLIR.IR.Attribute","text":"Attribute(type, str)\n\nCreates a string attribute in the given context containing the given string. Additionally, the attribute has the given type.\n\n\n\n\n\n","category":"method"},{"location":"IR/attribute/#MLIR.IR.Attribute-Tuple{MLIR.IR.Type}","page":"Attribute","title":"MLIR.IR.Attribute","text":"Attribute(type)\n\nCreates a type attribute wrapping the given type in the same context as the type.\n\n\n\n\n\n","category":"method"},{"location":"IR/attribute/#MLIR.IR.Attribute-Tuple{T} where T<:AbstractFloat","page":"Attribute","title":"MLIR.IR.Attribute","text":"Attribute(float; context=context(), location=Location(), check=false)\n\nCreates a floating point attribute in the given context with the given double value and double-precision FP semantics. If check=true, emits appropriate diagnostics on illegal arguments.\n\n\n\n\n\n","category":"method"},{"location":"IR/attribute/#MLIR.IR.Attribute-Tuple{Vector{MLIR.IR.Attribute}}","page":"Attribute","title":"MLIR.IR.Attribute","text":"Attribute(elements; context=context())\n\nCreates an array element containing the given list of elements in the given context.\n\n\n\n\n\n","category":"method"},{"location":"IR/attribute/#MLIR.IR.Attribute-Tuple{}","page":"Attribute","title":"MLIR.IR.Attribute","text":"Attribute()\n\nReturns an empty attribute.\n\n\n\n\n\n","category":"method"},{"location":"IR/attribute/#MLIR.IR.Attribute-Union{Tuple{T}, Tuple{T, Any}} where T<:Integer","page":"Attribute","title":"MLIR.IR.Attribute","text":"Attribute(int)\n\nCreates an integer attribute of the given type with the given integer value.\n\n\n\n\n\n","category":"method"},{"location":"IR/attribute/#MLIR.IR.NamedAttribute-Tuple{Any, Any}","page":"Attribute","title":"MLIR.IR.NamedAttribute","text":"NamedAttribute(name, attr)\n\nAssociates an attribute with the name. Takes ownership of neither.\n\n\n\n\n\n","category":"method"},{"location":"IR/attribute/#MLIR.IR.Type-Tuple{MLIR.IR.Attribute}","page":"Attribute","title":"MLIR.IR.Type","text":"Type(attr)\n\nReturns the type stored in the given type attribute.\n\n\n\n\n\n","category":"method"},{"location":"IR/attribute/#Base.:==-Tuple{MLIR.IR.Attribute, MLIR.IR.Attribute}","page":"Attribute","title":"Base.:==","text":"==(a1, a2)\n\nChecks if two attributes are equal.\n\n\n\n\n\n","category":"method"},{"location":"IR/attribute/#Base.fill-Tuple{MLIR.IR.Attribute, MLIR.IR.Type}","page":"Attribute","title":"Base.fill","text":"fill(attr, shapedType)\n\nCreates a dense elements attribute with the given Shaped type containing a single replicated element (splat).\n\n\n\n\n\n","category":"method"},{"location":"IR/attribute/#Base.parse-Tuple{Type{MLIR.IR.Attribute}, Any}","page":"Attribute","title":"Base.parse","text":"parse(::Core.Type{Attribute}, str; context=context())\n\nParses an attribute. The attribute is owned by the context.\n\n\n\n\n\n","category":"method"},{"location":"IR/attribute/#Base.reshape-Tuple{MLIR.IR.Attribute, Any}","page":"Attribute","title":"Base.reshape","text":"Base.reshape(attr, shapedType)\n\nCreates a dense elements attribute that has the same data as the given dense elements attribute and a different shaped type. The new type must have the same total number of elements.\n\n\n\n\n\n","category":"method"},{"location":"IR/attribute/#MLIR.IR.DenseArrayAttribute","page":"Attribute","title":"MLIR.IR.DenseArrayAttribute","text":"DenseArrayAttribute(array; context=context())\n\nCreate a dense array attribute with the given elements.\n\n\n\n\n\n","category":"function"},{"location":"IR/attribute/#MLIR.IR.DenseElementsAttribute-Tuple{AbstractArray{String}}","page":"Attribute","title":"MLIR.IR.DenseElementsAttribute","text":"DenseElementsAttribute(array::AbstractArray{String})\n\nCreates a dense elements attribute with the given shaped type from string elements.\n\n\n\n\n\n","category":"method"},{"location":"IR/attribute/#MLIR.IR.DenseElementsAttribute-Tuple{AbstractVector{Bool}}","page":"Attribute","title":"MLIR.IR.DenseElementsAttribute","text":"DenseElementsAttribute(array::AbstractArray)\n\nCreates a dense elements attribute with the given shaped type from elements of a specific type. Expects the element type of the shaped type to match the data element type.\n\n\n\n\n\n","category":"method"},{"location":"IR/attribute/#MLIR.IR.DenseElementsAttribute-Tuple{MLIR.IR.Type, AbstractArray}","page":"Attribute","title":"MLIR.IR.DenseElementsAttribute","text":"DenseElementsAttribute(shapedType, elements)\n\nCreates a dense elements attribute with the given Shaped type and elements in the same context as the type.\n\n\n\n\n\n","category":"method"},{"location":"IR/attribute/#MLIR.IR.FlatSymbolRefAttribute-Tuple{String}","page":"Attribute","title":"MLIR.IR.FlatSymbolRefAttribute","text":"FlatSymbolRefAttribute(ctx, symbol)\n\nCreates a flat symbol reference attribute in the given context referencing a symbol identified by the given string.\n\n\n\n\n\n","category":"method"},{"location":"IR/attribute/#MLIR.IR.OpaqueAttribute-Tuple{Any, Any, Any}","page":"Attribute","title":"MLIR.IR.OpaqueAttribute","text":"OpaqueAttribute(dialectNamespace, dataLength, data, type; context=context())\n\nCreates an opaque attribute in the given context associated with the dialect identified by its namespace. The attribute contains opaque byte data of the specified length (data need not be null-terminated).\n\n\n\n\n\n","category":"method"},{"location":"IR/attribute/#MLIR.IR.SymbolRefAttribute-Tuple{String, Vector{MLIR.IR.Attribute}}","page":"Attribute","title":"MLIR.IR.SymbolRefAttribute","text":"SymbolRefAttribute(symbol, references; context=context())\n\nCreates a symbol reference attribute in the given context referencing a symbol identified by the given string inside a list of nested references. Each of the references in the list must not be nested.\n\n\n\n\n\n","category":"method"},{"location":"IR/attribute/#MLIR.IR.UnitAttribute-Tuple{}","page":"Attribute","title":"MLIR.IR.UnitAttribute","text":"UnitAttribute(; context=context())\n\nCreates a unit attribute in the given context.\n\n\n\n\n\n","category":"method"},{"location":"IR/attribute/#MLIR.IR.context-Tuple{MLIR.IR.Attribute}","page":"Attribute","title":"MLIR.IR.context","text":"context(attribute)\n\nGets the context that an attribute was created with.\n\n\n\n\n\n","category":"method"},{"location":"IR/attribute/#MLIR.IR.data-Tuple{MLIR.IR.Attribute}","page":"Attribute","title":"MLIR.IR.data","text":"data(attr)\n\nReturns the raw data as a string reference. The data remains live as long as the context in which the attribute lives.\n\n\n\n\n\n","category":"method"},{"location":"IR/attribute/#MLIR.IR.flatsymbol-Tuple{MLIR.IR.Attribute}","page":"Attribute","title":"MLIR.IR.flatsymbol","text":"flatsymbol(attr)\n\nReturns the referenced symbol as a string reference. The data remains live as long as the context in which the attribute lives.\n\n\n\n\n\n","category":"method"},{"location":"IR/attribute/#MLIR.IR.isaffinemap-Tuple{MLIR.IR.Attribute}","page":"Attribute","title":"MLIR.IR.isaffinemap","text":"isaffinemap(attr)\n\nChecks whether the given attribute is an affine map attribute.\n\n\n\n\n\n","category":"method"},{"location":"IR/attribute/#MLIR.IR.isarray-Tuple{MLIR.IR.Attribute}","page":"Attribute","title":"MLIR.IR.isarray","text":"isarray(attr)\n\nChecks whether the given attribute is an array attribute.\n\n\n\n\n\n","category":"method"},{"location":"IR/attribute/#MLIR.IR.isbool-Tuple{MLIR.IR.Attribute}","page":"Attribute","title":"MLIR.IR.isbool","text":"isbool(attr)\n\nChecks whether the given attribute is a bool attribute.\n\n\n\n\n\n","category":"method"},{"location":"IR/attribute/#MLIR.IR.isdensearray","page":"Attribute","title":"MLIR.IR.isdensearray","text":"isdensearray(attr, ::Core.Type{T})\n\nChecks whether the given attribute is a dense array attribute.\n\n\n\n\n\n","category":"function"},{"location":"IR/attribute/#MLIR.IR.isdenseelements-Tuple{MLIR.IR.Attribute}","page":"Attribute","title":"MLIR.IR.isdenseelements","text":"isdenseelements(attr)\n\nChecks whether the given attribute is a dense elements attribute.\n\n\n\n\n\n","category":"method"},{"location":"IR/attribute/#MLIR.IR.isdict-Tuple{MLIR.IR.Attribute}","page":"Attribute","title":"MLIR.IR.isdict","text":"isdict(attr)\n\nChecks whether the given attribute is a dictionary attribute.\n\n\n\n\n\n","category":"method"},{"location":"IR/attribute/#MLIR.IR.iselements-Tuple{MLIR.IR.Attribute}","page":"Attribute","title":"MLIR.IR.iselements","text":"iselements(attr)\n\nChecks whether the given attribute is an elements attribute.\n\n\n\n\n\n","category":"method"},{"location":"IR/attribute/#MLIR.IR.isflatsymbolref-Tuple{MLIR.IR.Attribute}","page":"Attribute","title":"MLIR.IR.isflatsymbolref","text":"isflatsymbolref(attr)\n\nChecks whether the given attribute is a flat symbol reference attribute.\n\n\n\n\n\n","category":"method"},{"location":"IR/attribute/#MLIR.IR.isfloat-Tuple{MLIR.IR.Attribute}","page":"Attribute","title":"MLIR.IR.isfloat","text":"isfloat(attr)\n\nChecks whether the given attribute is a floating point attribute.\n\n\n\n\n\n","category":"method"},{"location":"IR/attribute/#MLIR.IR.isinteger-Tuple{MLIR.IR.Attribute}","page":"Attribute","title":"MLIR.IR.isinteger","text":"isinteger(attr)\n\nChecks whether the given attribute is an integer attribute.\n\n\n\n\n\n","category":"method"},{"location":"IR/attribute/#MLIR.IR.isintegerset-Tuple{MLIR.IR.Attribute}","page":"Attribute","title":"MLIR.IR.isintegerset","text":"isintegerset(attr)\n\nChecks whether the given attribute is an integer set attribute.\n\n\n\n\n\n","category":"method"},{"location":"IR/attribute/#MLIR.IR.isopaque-Tuple{MLIR.IR.Attribute}","page":"Attribute","title":"MLIR.IR.isopaque","text":"isopaque(attr)\n\nChecks whether the given attribute is an opaque attribute.\n\n\n\n\n\n","category":"method"},{"location":"IR/attribute/#MLIR.IR.isopaqueelements-Tuple{MLIR.IR.Attribute}","page":"Attribute","title":"MLIR.IR.isopaqueelements","text":"isopaqueelements(attr)\n\nChecks whether the given attribute is an opaque elements attribute.\n\n\n\n\n\n","category":"method"},{"location":"IR/attribute/#MLIR.IR.issparseelements-Tuple{MLIR.IR.Attribute}","page":"Attribute","title":"MLIR.IR.issparseelements","text":"issparseelements(attr)\n\nChecks whether the given attribute is a sparse elements attribute.\n\n\n\n\n\n","category":"method"},{"location":"IR/attribute/#MLIR.IR.issplat-Tuple{MLIR.IR.Attribute}","page":"Attribute","title":"MLIR.IR.issplat","text":"issplat(attr)\n\nChecks whether the given dense elements attribute contains a single replicated value (splat).\n\n\n\n\n\n","category":"method"},{"location":"IR/attribute/#MLIR.IR.isstring-Tuple{MLIR.IR.Attribute}","page":"Attribute","title":"MLIR.IR.isstring","text":"isstring(attr)\n\nChecks whether the given attribute is a string attribute.\n\n\n\n\n\n","category":"method"},{"location":"IR/attribute/#MLIR.IR.issymbolref-Tuple{MLIR.IR.Attribute}","page":"Attribute","title":"MLIR.IR.issymbolref","text":"issymbolref(attr)\n\nChecks whether the given attribute is a symbol reference attribute.\n\n\n\n\n\n","category":"method"},{"location":"IR/attribute/#MLIR.IR.istype-Tuple{MLIR.IR.Attribute}","page":"Attribute","title":"MLIR.IR.istype","text":"istype(attr)\n\nChecks whether the given attribute is a type attribute.\n\n\n\n\n\n","category":"method"},{"location":"IR/attribute/#MLIR.IR.isunit-Tuple{MLIR.IR.Attribute}","page":"Attribute","title":"MLIR.IR.isunit","text":"isunit(attr)\n\nChecks whether the given attribute is a unit attribute.\n\n\n\n\n\n","category":"method"},{"location":"IR/attribute/#MLIR.IR.leafref-Tuple{MLIR.IR.Attribute}","page":"Attribute","title":"MLIR.IR.leafref","text":"leafref(attr)\n\nReturns the string reference to the leaf referenced symbol. The data remains live as long as the context in which the attribute lives.\n\n\n\n\n\n","category":"method"},{"location":"IR/attribute/#MLIR.IR.namespace-Tuple{MLIR.IR.Attribute}","page":"Attribute","title":"MLIR.IR.namespace","text":"mlirOpaqueAttrGetDialectNamespace(attr)\n\nReturns the namespace of the dialect with which the given opaque attribute is associated. The namespace string is owned by the context.\n\n\n\n\n\n","category":"method"},{"location":"IR/attribute/#MLIR.IR.nnestedrefs-Tuple{MLIR.IR.Attribute}","page":"Attribute","title":"MLIR.IR.nnestedrefs","text":"nnestedrefs(attr)\n\nReturns the number of references nested in the given symbol reference attribute.\n\n\n\n\n\n","category":"method"},{"location":"IR/attribute/#MLIR.IR.rootref-Tuple{MLIR.IR.Attribute}","page":"Attribute","title":"MLIR.IR.rootref","text":"rootref(attr)\n\nReturns the string reference to the root referenced symbol. The data remains live as long as the context in which the attribute lives.\n\n\n\n\n\n","category":"method"},{"location":"IR/attribute/#MLIR.IR.type-Tuple{MLIR.IR.Attribute}","page":"Attribute","title":"MLIR.IR.type","text":"type(attribute)\n\nGets the type of this attribute.\n\n\n\n\n\n","category":"method"},{"location":"IR/attribute/#MLIR.IR.typeid-Tuple{MLIR.IR.Attribute}","page":"Attribute","title":"MLIR.IR.typeid","text":"typeid(attribute)\n\nGets the type id of the attribute.\n\n\n\n\n\n","category":"method"},{"location":"api/#API","page":"API","title":"API","text":"","category":"section"},{"location":"api/#Types-and-constants","page":"API","title":"Types and constants","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Modules = [MLIR.API]\nOrder = [:type, :constant]","category":"page"},{"location":"api/#Functions-and-macros","page":"API","title":"Functions and macros","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Modules = [MLIR.API]\nOrder = [:macro, :function]","category":"page"},{"location":"api/#Documentation","page":"API","title":"Documentation","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Modules = [MLIR.API]\nOrder = [:module, :type, :constant, :macro, :function]","category":"page"},{"location":"dialects/bufferization/#bufferization-dialect","page":"bufferization","title":"bufferization dialect","text":"","category":"section"},{"location":"dialects/bufferization/","page":"bufferization","title":"bufferization","text":"Modules = [MLIR.Dialects.bufferization]\nPages = [\"Dialects/15/Bufferization.jl\"]","category":"page"},{"location":"dialects/openmp/#omp-dialect","page":"openmp","title":"omp dialect","text":"","category":"section"},{"location":"dialects/openmp/","page":"openmp","title":"openmp","text":"Modules = [MLIR.Dialects.omp]\nPages = [\"Dialects/15/OpenMP.jl\"]","category":"page"},{"location":"IR/dialect/#Dialect","page":"Dialect","title":"Dialect","text":"","category":"section"},{"location":"IR/dialect/","page":"Dialect","title":"Dialect","text":"Modules = [MLIR.IR]\nPages = [\"IR/Dialect.jl\"]","category":"page"},{"location":"IR/logicalresult/#Logical-Result","page":"LogicalResult","title":"Logical Result","text":"","category":"section"},{"location":"IR/logicalresult/","page":"LogicalResult","title":"LogicalResult","text":"Modules = [MLIR.IR]\nPages = [\"IR/LogicalResult.jl\"]","category":"page"},{"location":"IR/logicalresult/#MLIR.IR.LogicalResult","page":"LogicalResult","title":"MLIR.IR.LogicalResult","text":"LogicalResult\n\nA logical result value, essentially a boolean with named states. LLVM convention for using boolean values to designate success or failure of an operation is a moving target, so MLIR opted for an explicit class. Instances of LogicalResult must only be inspected using the associated functions.\n\n\n\n\n\n","category":"type"},{"location":"IR/logicalresult/#MLIR.IR.failure-Tuple{}","page":"LogicalResult","title":"MLIR.IR.failure","text":"failure()\n\nCreates a logical result representing a failure.\n\n\n\n\n\n","category":"method"},{"location":"IR/logicalresult/#MLIR.IR.isfailure-Tuple{MLIR.IR.LogicalResult}","page":"LogicalResult","title":"MLIR.IR.isfailure","text":"isfailure(res)\n\nChecks if the given logical result represents a failure.\n\n\n\n\n\n","category":"method"},{"location":"IR/logicalresult/#MLIR.IR.issuccess-Tuple{MLIR.IR.LogicalResult}","page":"LogicalResult","title":"MLIR.IR.issuccess","text":"issuccess(res)\n\nChecks if the given logical result represents a success.\n\n\n\n\n\n","category":"method"},{"location":"IR/logicalresult/#MLIR.IR.success-Tuple{}","page":"LogicalResult","title":"MLIR.IR.success","text":"success()\n\nCreates a logical result representing a success.\n\n\n\n\n\n","category":"method"},{"location":"dialects/nvgpu/#nvgpu-dialect","page":"nvgpu","title":"nvgpu dialect","text":"","category":"section"},{"location":"dialects/nvgpu/","page":"nvgpu","title":"nvgpu","text":"Modules = [MLIR.Dialects.nvgpu]\nPages = [\"Dialects/15/NVGPU.jl\"]","category":"page"},{"location":"IR/iterators/#Iterators","page":"Iterators","title":"Iterators","text":"","category":"section"},{"location":"IR/iterators/","page":"Iterators","title":"Iterators","text":"Modules = [MLIR.IR]\nPages = [\"IR/Iterators.jl\"]","category":"page"},{"location":"IR/iterators/#MLIR.IR.BlockIterator","page":"Iterators","title":"MLIR.IR.BlockIterator","text":"BlockIterator(region::Region)\n\nIterates over all blocks in the given region.\n\n\n\n\n\n","category":"type"},{"location":"IR/iterators/#MLIR.IR.OperationIterator","page":"Iterators","title":"MLIR.IR.OperationIterator","text":"OperationIterator(block::Block)\n\nIterates over all operations for the given block.\n\n\n\n\n\n","category":"type"},{"location":"IR/iterators/#MLIR.IR.RegionIterator","page":"Iterators","title":"MLIR.IR.RegionIterator","text":"RegionIterator(::Operation)\n\nIterates over all sub-regions for the given operation.\n\n\n\n\n\n","category":"type"},{"location":"dialects/ml_program/#ml_program-dialect","page":"ml_program","title":"ml_program dialect","text":"","category":"section"},{"location":"dialects/ml_program/","page":"ml_program","title":"ml_program","text":"Modules = [MLIR.Dialects.ml_program]\nPages = [\"Dialects/15/MLProgram.jl\"]","category":"page"},{"location":"#MLIR.jl","page":"Home","title":"MLIR.jl","text":"","category":"section"},{"location":"#Design","page":"Home","title":"Design","text":"","category":"section"},{"location":"#String-and-MlirStringRef","page":"Home","title":"String and MlirStringRef","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"MlirStringRef is a non-owning pointer, the caller is in charge of performing necessary copies or ensuring that the pointee outlives all uses of MlirStringRef. Since Julia is a GC'd language special care must be taken around the live-time of Julia objects such as Strings when interacting with foreign libraries.","category":"page"},{"location":"","page":"Home","title":"Home","text":"For convenience and safty sake, users of the API should use Julia String or Symbol as the argument to the C-ABI of MLIR instead of directly using MlirStringRef. We translate (cheaply) between Julia String and MlirStringRef.","category":"page"},{"location":"dialects/tosa/#tosa-dialect","page":"tosa","title":"tosa dialect","text":"","category":"section"},{"location":"dialects/tosa/","page":"tosa","title":"tosa","text":"Modules = [MLIR.Dialects.tosa]\nPages = [\"Dialects/15/Tosa.jl\"]","category":"page"},{"location":"dialects/amx/#amx-dialect","page":"amx","title":"amx dialect","text":"","category":"section"},{"location":"dialects/amx/","page":"amx","title":"amx","text":"Modules = [MLIR.Dialects.amx]\nPages = [\"Dialects/15/AMX.jl\"]","category":"page"},{"location":"dialects/func/#func-dialect","page":"func","title":"func dialect","text":"","category":"section"},{"location":"dialects/func/","page":"func","title":"func","text":"Modules = [MLIR.Dialects.func]\nPages = [\"Dialects/15/Func.jl\"]","category":"page"},{"location":"dialects/scf/#scf-dialect","page":"scf","title":"scf dialect","text":"","category":"section"},{"location":"dialects/scf/","page":"scf","title":"scf","text":"Modules = [MLIR.Dialects.scf]\nPages = [\"Dialects/15/SCF.jl\"]","category":"page"},{"location":"IR/affinemap/#Affine-Map","page":"AffineMap","title":"Affine Map","text":"","category":"section"},{"location":"IR/affinemap/","page":"AffineMap","title":"AffineMap","text":"Modules = [MLIR.IR]\nPages = [\"IR/AffineMap.jl\"]","category":"page"},{"location":"IR/affinemap/#MLIR.IR.AffineMap-Tuple{Any, Any, Vector{MLIR.IR.AffineExpr}}","page":"AffineMap","title":"MLIR.IR.AffineMap","text":"AffineMap(ndims, nsymbols, affineExprs; context=context())\n\nCreates an affine map with results defined by the given list of affine expressions. The map resulting map also has the requested number of input dimensions and symbols, regardless of them being used in the results.\n\n\n\n\n\n","category":"method"},{"location":"IR/affinemap/#MLIR.IR.AffineMap-Tuple{Any, Any}","page":"AffineMap","title":"MLIR.IR.AffineMap","text":"AffineMap(ndims, nsymbols; context=context())\n\nCreates a zero result affine map of the given dimensions and symbols in the context. The affine map is owned by the context.\n\n\n\n\n\n","category":"method"},{"location":"IR/affinemap/#MLIR.IR.AffineMap-Tuple{}","page":"AffineMap","title":"MLIR.IR.AffineMap","text":"AffineMap(; context=context())\n\nCreates a zero result affine map with no dimensions or symbols in the context. The affine map is owned by the context.\n\n\n\n\n\n","category":"method"},{"location":"IR/affinemap/#Base.:==-Tuple{MLIR.IR.AffineMap, MLIR.IR.AffineMap}","page":"AffineMap","title":"Base.:==","text":"==(a, b)\n\nChecks if two affine maps are equal.\n\n\n\n\n\n","category":"method"},{"location":"IR/affinemap/#Base.isempty-Tuple{MLIR.IR.AffineMap}","page":"AffineMap","title":"Base.isempty","text":"isempty(affineMap)\n\nChecks whether the given affine map is an empty affine map.\n\n\n\n\n\n","category":"method"},{"location":"IR/affinemap/#Base.isperm-Tuple{MLIR.IR.AffineMap}","page":"AffineMap","title":"Base.isperm","text":"isperm(affineMap)\n\nChecks whether the given affine map represents a symbol-less permutation map.\n\n\n\n\n\n","category":"method"},{"location":"IR/affinemap/#Base.ndims-Tuple{MLIR.IR.AffineMap}","page":"AffineMap","title":"Base.ndims","text":"ndims(affineMap)\n\nReturns the number of dimensions of the given affine map.\n\n\n\n\n\n","category":"method"},{"location":"IR/affinemap/#Base.replace-Tuple{MLIR.IR.AffineMap, Pair{MLIR.IR.AffineExpr, MLIR.IR.AffineExpr}, Any, Any}","page":"AffineMap","title":"Base.replace","text":"mlirAffineMapReplace(affineMap, expression => replacement, numResultDims, numResultSyms)\n\nApply AffineExpr::replace(map) to each of the results and return a new new AffineMap with the new results and the specified number of dims and symbols.\n\n\n\n\n\n","category":"method"},{"location":"IR/affinemap/#MLIR.IR.ConstantAffineMap-Tuple{Any}","page":"AffineMap","title":"MLIR.IR.ConstantAffineMap","text":"ConstantAffineMap(val; context=context())\n\nCreates a single constant result affine map in the context. The affine map is owned by the context.\n\n\n\n\n\n","category":"method"},{"location":"IR/affinemap/#MLIR.IR.IdentityAffineMap-Tuple{Any}","page":"AffineMap","title":"MLIR.IR.IdentityAffineMap","text":"IdentityAffineMap(ndims; context=context())\n\nCreates an affine map with 'ndims' identity in the context. The affine map is owned by the context.\n\n\n\n\n\n","category":"method"},{"location":"IR/affinemap/#MLIR.IR.MinorIdentityAffineMap-Tuple{Any, Any}","page":"AffineMap","title":"MLIR.IR.MinorIdentityAffineMap","text":"MinorIdentityAffineMap(ndims, nresults; context=context())\n\nCreates an identity affine map on the most minor dimensions in the context. The affine map is owned by the context. The function asserts that the number of dimensions is greater or equal to the number of results.\n\n\n\n\n\n","category":"method"},{"location":"IR/affinemap/#MLIR.IR.PermutationAffineMap-Tuple{Any}","page":"AffineMap","title":"MLIR.IR.PermutationAffineMap","text":"PermutationAffineMap(permutation; context=context())\n\nCreates an affine map with a permutation expression and its size in the context. The permutation expression is a non-empty vector of integers. The elements of the permutation vector must be continuous from 0 and cannot be repeated (i.e. [1,2,0] is a valid permutation. [2,0] or [1,1,2] is an invalid invalid permutation). The affine map is owned by the context.\n\n\n\n\n\n","category":"method"},{"location":"IR/affinemap/#MLIR.IR.compose-Tuple{MLIR.IR.AffineExpr, MLIR.IR.AffineMap}","page":"AffineMap","title":"MLIR.IR.compose","text":"compose(affineExpr, affineMap)\n\nComposes the given map with the given expression.\n\n\n\n\n\n","category":"method"},{"location":"IR/affinemap/#MLIR.IR.context-Tuple{MLIR.IR.AffineMap}","page":"AffineMap","title":"MLIR.IR.context","text":"context(affineMap)\n\nGets the context that the given affine map was created with.\n\n\n\n\n\n","category":"method"},{"location":"IR/affinemap/#MLIR.IR.isidentity-Tuple{MLIR.IR.AffineMap}","page":"AffineMap","title":"MLIR.IR.isidentity","text":"isidentity(affineMap)\n\nChecks whether the given affine map is an identity affine map. The function asserts that the number of dimensions is greater or equal to the number of results.\n\n\n\n\n\n","category":"method"},{"location":"IR/affinemap/#MLIR.IR.isminoridentity-Tuple{MLIR.IR.AffineMap}","page":"AffineMap","title":"MLIR.IR.isminoridentity","text":"isminoridentity(affineMap)\n\nChecks whether the given affine map is a minor identity affine map.\n\n\n\n\n\n","category":"method"},{"location":"IR/affinemap/#MLIR.IR.isprojperm-Tuple{MLIR.IR.AffineMap}","page":"AffineMap","title":"MLIR.IR.isprojperm","text":"isprojperm(affineMap)\n\nChecks whether the given affine map represents a subset of a symbol-less permutation map.\n\n\n\n\n\n","category":"method"},{"location":"IR/affinemap/#MLIR.IR.issingleconstant-Tuple{MLIR.IR.AffineMap}","page":"AffineMap","title":"MLIR.IR.issingleconstant","text":"issingleconstant(affineMap)\n\nChecks whether the given affine map is a single result constant affine map.\n\n\n\n\n\n","category":"method"},{"location":"IR/affinemap/#MLIR.IR.majorsubmap-Tuple{MLIR.IR.AffineMap, Any}","page":"AffineMap","title":"MLIR.IR.majorsubmap","text":"majorsubmap(affineMap, nresults)\n\nReturns the affine map consisting of the most major nresults results. Returns the null AffineMap if the nresults is equal to zero. Returns the affineMap if nresults is greater or equals to number of results of the given affine map.\n\n\n\n\n\n","category":"method"},{"location":"IR/affinemap/#MLIR.IR.minorsubmap-Tuple{MLIR.IR.AffineMap, Any}","page":"AffineMap","title":"MLIR.IR.minorsubmap","text":"minorsubmap(affineMap, nresults)\n\nReturns the affine map consisting of the most minor nresults results. Returns the null AffineMap if the nresults is equal to zero. Returns the affineMap if nresults is greater or equals to number of results of the given affine map.\n\n\n\n\n\n","category":"method"},{"location":"IR/affinemap/#MLIR.IR.ninputs-Tuple{MLIR.IR.AffineMap}","page":"AffineMap","title":"MLIR.IR.ninputs","text":"ninputs(affineMap)\n\nReturns the number of inputs (dimensions + symbols) of the given affine map.\n\n\n\n\n\n","category":"method"},{"location":"IR/affinemap/#MLIR.IR.nresults-Tuple{MLIR.IR.AffineMap}","page":"AffineMap","title":"MLIR.IR.nresults","text":"nresults(affineMap)\n\nReturns the number of results of the given affine map.\n\n\n\n\n\n","category":"method"},{"location":"IR/affinemap/#MLIR.IR.nsymbols-Tuple{MLIR.IR.AffineMap}","page":"AffineMap","title":"MLIR.IR.nsymbols","text":"nsymbols(affineMap)\n\nReturns the number of symbols of the given affine map.\n\n\n\n\n\n","category":"method"},{"location":"IR/affinemap/#MLIR.IR.result-Tuple{MLIR.IR.AffineMap, Any}","page":"AffineMap","title":"MLIR.IR.result","text":"result(affineMap, pos)\n\nReturns the result at the given position.\n\n\n\n\n\n","category":"method"},{"location":"IR/affinemap/#MLIR.IR.result-Tuple{MLIR.IR.AffineMap}","page":"AffineMap","title":"MLIR.IR.result","text":"result(affineMap)\n\nReturns the constant result of the given affine map. The function asserts that the map has a single constant result.\n\n\n\n\n\n","category":"method"},{"location":"IR/affinemap/#MLIR.IR.submap-Tuple{MLIR.IR.AffineMap, Vector{Int64}}","page":"AffineMap","title":"MLIR.IR.submap","text":"submap(affineMap, positions)\n\nReturns the affine map consisting of the positions subset.\n\n\n\n\n\n","category":"method"},{"location":"IR/affinemap/#MLIR.IR.@affinemap-Tuple{Any}","page":"AffineMap","title":"MLIR.IR.@affinemap","text":"@affinemap (d1, d2, d3, ...)[s1, s2, ...] -> (d0 + d1, ...)\n\nReturns an affine map from the provided Julia expression. On the right hand side are allowed the following function calls:\n\n+, *, ÷, %, fld, cld\n\nThe rhs can only contains dimensions and symbols present on the left hand side or integer literals.\n\njulia> using MLIR: IR, AffineUtils\n\njulia> IR.context!(IR.Context()) do\n           IR.@affinemap (d1, d2)[s0] -> (d1 + s0, d2 % 10)\n       end\nMLIR.IR.AffineMap(#= (d0, d1)[s0] -> (d0 + s0, d1 mod 10) =#)\n\n\n\n\n\n","category":"macro"},{"location":"dialects/x86vector/#x86vector-dialect","page":"x86vector","title":"x86vector dialect","text":"","category":"section"},{"location":"dialects/x86vector/","page":"x86vector","title":"x86vector","text":"Modules = [MLIR.Dialects.x86vector]\nPages = [\"Dialects/15/X86Vector.jl\"]","category":"page"},{"location":"dialects/arith/#arith-dialect","page":"arith","title":"arith dialect","text":"","category":"section"},{"location":"dialects/arith/","page":"arith","title":"arith","text":"Modules = [MLIR.Dialects.arith]\nPages = [\"Dialects/15/Arithmetic.jl\"]","category":"page"},{"location":"dialects/math/#math-dialect","page":"math","title":"math dialect","text":"","category":"section"},{"location":"dialects/math/","page":"math","title":"math","text":"Modules = [MLIR.Dialects.math]\nPages = [\"Dialects/15/Math.jl\"]","category":"page"},{"location":"dialects/pdl/#pdl-dialect","page":"pdl","title":"pdl dialect","text":"","category":"section"},{"location":"dialects/pdl/","page":"pdl","title":"pdl","text":"Modules = [MLIR.Dialects.pdl]\nPages = [\"Dialects/15/PDL.jl\"]","category":"page"},{"location":"IR/module/#Module","page":"Module","title":"Module","text":"","category":"section"},{"location":"IR/module/","page":"Module","title":"Module","text":"Modules = [MLIR.IR]\nPages = [\"IR/Module.jl\"]","category":"page"},{"location":"IR/module/#MLIR.IR.Module","page":"Module","title":"MLIR.IR.Module","text":"Module(location=Location())\n\nCreates a new, empty module and transfers ownership to the caller.\n\n\n\n\n\n","category":"type"},{"location":"IR/module/#MLIR.IR.Operation-Tuple{MLIR.IR.Module}","page":"Module","title":"MLIR.IR.Operation","text":"Operation(module)\n\nViews the module as a generic operation.\n\n\n\n\n\n","category":"method"},{"location":"IR/module/#Base.parse-Tuple{Type{MLIR.IR.Module}, Any}","page":"Module","title":"Base.parse","text":"parse(::Type{Module}, module; context=context())\n\nParses a module from the string and transfers ownership to the caller.\n\n\n\n\n\n","category":"method"},{"location":"IR/module/#MLIR.IR.body-Tuple{Any}","page":"Module","title":"MLIR.IR.body","text":"body(module)\n\nGets the body of the module, i.e. the only block it contains.\n\n\n\n\n\n","category":"method"},{"location":"IR/module/#MLIR.IR.context-Tuple{MLIR.IR.Module}","page":"Module","title":"MLIR.IR.context","text":"context(module)\n\nGets the context that a module was created with.\n\n\n\n\n\n","category":"method"},{"location":"dialects/arm_sve/#arm_sve-dialect","page":"arm_sve","title":"arm_sve dialect","text":"","category":"section"},{"location":"dialects/arm_sve/","page":"arm_sve","title":"arm_sve","text":"Modules = [MLIR.Dialects.arm_sve]\nPages = [\"Dialects/15/ArmSVE.jl\"]","category":"page"},{"location":"IR/symboltable/#Symbol-Table","page":"SymbolTable","title":"Symbol Table","text":"","category":"section"},{"location":"IR/symboltable/","page":"SymbolTable","title":"SymbolTable","text":"Modules = [MLIR.IR]\nPages = [\"IR/SymbolTable.jl\"]","category":"page"},{"location":"IR/symboltable/#MLIR.IR.SymbolTable-Tuple{MLIR.IR.Operation}","page":"SymbolTable","title":"MLIR.IR.SymbolTable","text":"mlirSymbolTableCreate(operation)\n\nCreates a symbol table for the given operation. If the operation does not have the SymbolTable trait, returns a null symbol table.\n\n\n\n\n\n","category":"method"},{"location":"IR/symboltable/#Base.push!-Tuple{MLIR.IR.SymbolTable, MLIR.IR.Operation}","page":"SymbolTable","title":"Base.push!","text":"push!(symboltable, operation)\n\nInserts the given operation into the given symbol table. The operation must have the symbol trait. If the symbol table already has a symbol with the same name, renames the symbol being inserted to ensure name uniqueness. Note that this does not move the operation itself into the block of the symbol table operation, this should be done separately. Returns the name of the symbol after insertion.\n\n\n\n\n\n","category":"method"},{"location":"IR/symboltable/#MLIR.IR.delete!-Tuple{MLIR.IR.SymbolTable, MLIR.IR.Operation}","page":"SymbolTable","title":"MLIR.IR.delete!","text":"delete!(symboltable, operation)\n\nRemoves the given operation from the symbol table and erases it.\n\n\n\n\n\n","category":"method"},{"location":"IR/symboltable/#MLIR.IR.lookup-Tuple{MLIR.IR.SymbolTable, AbstractString}","page":"SymbolTable","title":"MLIR.IR.lookup","text":"lookup(symboltable, name)\n\nLooks up a symbol with the given name in the given symbol table and returns the operation that corresponds to the symbol. If the symbol cannot be found, returns a null operation.\n\n\n\n\n\n","category":"method"},{"location":"IR/block/#Block","page":"Block","title":"Block","text":"","category":"section"},{"location":"IR/block/","page":"Block","title":"Block","text":"Modules = [MLIR.IR]\nPages = [\"IR/Block.jl\"]","category":"page"},{"location":"IR/block/#MLIR.IR.Block-Tuple{Vector{MLIR.IR.Type}, Vector{MLIR.IR.Location}}","page":"Block","title":"MLIR.IR.Block","text":"Block(args, locs)\n\nCreates a new empty block with the given argument types and transfers ownership to the caller.\n\n\n\n\n\n","category":"method"},{"location":"IR/block/#Base.:==-Tuple{MLIR.IR.Block, MLIR.IR.Block}","page":"Block","title":"Base.:==","text":"==(block, other)\n\nChecks whether two blocks handles point to the same block. This does not perform deep comparison.\n\n\n\n\n\n","category":"method"},{"location":"IR/block/#Base.insert!-Tuple{MLIR.IR.Block, Any, MLIR.IR.Operation}","page":"Block","title":"Base.insert!","text":"insert!(block, index, operation)\n\nTakes an operation owned by the caller and inserts it as index to the block. This is an expensive operation that scans the block linearly, prefer insertBefore/After instead.\n\n\n\n\n\n","category":"method"},{"location":"IR/block/#Base.push!-Tuple{MLIR.IR.Block, MLIR.IR.Operation}","page":"Block","title":"Base.push!","text":"push!(block, operation)\n\nTakes an operation owned by the caller and appends it to the block.\n\n\n\n\n\n","category":"method"},{"location":"IR/block/#MLIR.IR.argument-Tuple{MLIR.IR.Block, Any}","page":"Block","title":"MLIR.IR.argument","text":"argument(block, i)\n\nReturns i-th argument of the block.\n\n\n\n\n\n","category":"method"},{"location":"IR/block/#MLIR.IR.first_op-Tuple{MLIR.IR.Block}","page":"Block","title":"MLIR.IR.first_op","text":"first_op(block)\n\nReturns the first operation in the block or nothing if empty.\n\n\n\n\n\n","category":"method"},{"location":"IR/block/#MLIR.IR.insert_after!-Tuple{MLIR.IR.Block, MLIR.IR.Operation, MLIR.IR.Operation}","page":"Block","title":"MLIR.IR.insert_after!","text":"insert_after!(block, reference, operation)\n\nTakes an operation owned by the caller and inserts it after the (non-owned) reference operation in the given block. If the reference is null, prepends the operation. Otherwise, the reference must belong to the block.\n\n\n\n\n\n","category":"method"},{"location":"IR/block/#MLIR.IR.insert_before!-Tuple{MLIR.IR.Block, MLIR.IR.Operation, MLIR.IR.Operation}","page":"Block","title":"MLIR.IR.insert_before!","text":"insert_before!(block, reference, operation)\n\nTakes an operation owned by the caller and inserts it before the (non-owned) reference operation in the given block. If the reference is null, appends the operation. Otherwise, the reference must belong to the block.\n\n\n\n\n\n","category":"method"},{"location":"IR/block/#MLIR.IR.nargs-Tuple{MLIR.IR.Block}","page":"Block","title":"MLIR.IR.nargs","text":"nargs(block)\n\nReturns the number of arguments of the block.\n\n\n\n\n\n","category":"method"},{"location":"IR/block/#MLIR.IR.next-Tuple{MLIR.IR.Block}","page":"Block","title":"MLIR.IR.next","text":"next(block)\n\nReturns the block immediately following the given block in its parent region or nothing if last.\n\n\n\n\n\n","category":"method"},{"location":"IR/block/#MLIR.IR.parent_op-Tuple{MLIR.IR.Block}","page":"Block","title":"MLIR.IR.parent_op","text":"parent_op(block)\n\nReturns the closest surrounding operation that contains this block.\n\n\n\n\n\n","category":"method"},{"location":"IR/block/#MLIR.IR.parent_region-Tuple{MLIR.IR.Block}","page":"Block","title":"MLIR.IR.parent_region","text":"parent_region(block)\n\nReturns the region that contains this block.\n\n\n\n\n\n","category":"method"},{"location":"IR/block/#MLIR.IR.push_argument!-Tuple{MLIR.IR.Block, Any}","page":"Block","title":"MLIR.IR.push_argument!","text":"push_argument!(block, type; location=Location())\n\nAppends an argument of the specified type to the block. Returns the newly added argument.\n\n\n\n\n\n","category":"method"},{"location":"IR/block/#MLIR.IR.terminator-Tuple{MLIR.IR.Block}","page":"Block","title":"MLIR.IR.terminator","text":"terminator(block)\n\nReturns the terminator operation in the block or nothing if no terminator.\n\n\n\n\n\n","category":"method"},{"location":"IR/pass/#Pass-Infrastructure","page":"Pass Infrastucture","title":"Pass Infrastructure","text":"","category":"section"},{"location":"IR/pass/","page":"Pass Infrastucture","title":"Pass Infrastucture","text":"Modules = [MLIR.IR]\nPages = [\"IR/Pass.jl\"]","category":"page"},{"location":"IR/pass/#MLIR.IR.OpPassManager-Tuple{MLIR.IR.OpPassManager, Any}","page":"Pass Infrastucture","title":"MLIR.IR.OpPassManager","text":"OpPassManager(opPassManager, operationName)\n\nNest an OpPassManager under the provided OpPassManager, the nested passmanager will only run on operations matching the provided name. The returned OpPassManager will be destroyed when the parent is destroyed.\n\n\n\n\n\n","category":"method"},{"location":"IR/pass/#MLIR.IR.OpPassManager-Tuple{MLIR.IR.PassManager, Any}","page":"Pass Infrastucture","title":"MLIR.IR.OpPassManager","text":"OpPassManager(passManager, operationName)\n\nNest an OpPassManager under the top-level PassManager, the nested passmanager will only run on operations matching the provided name. The returned OpPassManager will be destroyed when the parent is destroyed. To further nest more OpPassManager under the newly returned one, see mlirOpPassManagerNest below.\n\n\n\n\n\n","category":"method"},{"location":"IR/pass/#MLIR.IR.OpPassManager-Tuple{MLIR.IR.PassManager}","page":"Pass Infrastucture","title":"MLIR.IR.OpPassManager","text":"OpPassManager(passManager)\n\nCast a top-level PassManager to a generic OpPassManager.\n\n\n\n\n\n","category":"method"},{"location":"IR/pass/#MLIR.IR.PassManager-Tuple{MLIR.IR.Operation}","page":"Pass Infrastucture","title":"MLIR.IR.PassManager","text":"PassManager(anchorOp; context=context())\n\nCreate a new top-level PassManager anchored on anchorOp.\n\n\n\n\n\n","category":"method"},{"location":"IR/pass/#MLIR.IR.PassManager-Tuple{}","page":"Pass Infrastucture","title":"MLIR.IR.PassManager","text":"PassManager(; context=context())\n\nCreate a new top-level PassManager.\n\n\n\n\n\n","category":"method"},{"location":"IR/pass/#Base.parse-Tuple{MLIR.IR.OpPassManager, String}","page":"Pass Infrastucture","title":"Base.parse","text":"parse(passManager, pipeline)\n\nParse a textual MLIR pass pipeline and add it to the provided OpPassManager.\n\n\n\n\n\n","category":"method"},{"location":"IR/pass/#MLIR.IR.add_owned_pass!-Tuple{MLIR.IR.OpPassManager, Any}","page":"Pass Infrastucture","title":"MLIR.IR.add_owned_pass!","text":"add_owned_pass!(opPassManager, pass)\n\nAdd a pass and transfer ownership to the provided OpPassManager. If the pass is not a generic operation pass or matching the type of the provided OpPassManager, a new OpPassManager is implicitly nested under the provided OpPassManager.\n\n\n\n\n\n","category":"method"},{"location":"IR/pass/#MLIR.IR.add_owned_pass!-Tuple{MLIR.IR.PassManager, Any}","page":"Pass Infrastucture","title":"MLIR.IR.add_owned_pass!","text":"add_owned_pass!(passManager, pass)\n\nAdd a pass and transfer ownership to the provided top-level PassManager. If the pass is not a generic operation pass or a ModulePass, a new OpPassManager is implicitly nested under the provided PassManager.\n\n\n\n\n\n","category":"method"},{"location":"IR/pass/#MLIR.IR.add_pipeline!-Tuple{MLIR.IR.OpPassManager, Any}","page":"Pass Infrastucture","title":"MLIR.IR.add_pipeline!","text":"add_pipeline!(passManager, pipelineElements, callback, userData)\n\nParse a sequence of textual MLIR pass pipeline elements and add them to the provided OpPassManager. If parsing fails an error message is reported using the provided callback.\n\n\n\n\n\n","category":"method"},{"location":"IR/pass/#MLIR.IR.enable_ir_printing!-Tuple{Any}","page":"Pass Infrastucture","title":"MLIR.IR.enable_ir_printing!","text":"enable_ir_printing!(passManager)\n\nEnable mlir-print-ir-after-all.\n\n\n\n\n\n","category":"method"},{"location":"IR/pass/#MLIR.IR.enable_verifier!","page":"Pass Infrastucture","title":"MLIR.IR.enable_verifier!","text":"enable_verifier!(passManager, enable)\n\nEnable / disable verify-each.\n\n\n\n\n\n","category":"function"},{"location":"IR/pass/#MLIR.IR.run!-Tuple{MLIR.IR.PassManager, MLIR.IR.Module}","page":"Pass Infrastucture","title":"MLIR.IR.run!","text":"run!(passManager, module)\n\nRun the provided passManager on the given module.\n\n\n\n\n\n","category":"method"},{"location":"dialects/async/#async-dialect","page":"async","title":"async dialect","text":"","category":"section"},{"location":"dialects/async/","page":"async","title":"async","text":"Modules = [MLIR.Dialects.async]\nPages = [\"Dialects/15/Async.jl\"]","category":"page"},{"location":"IR/region/#Region","page":"Region","title":"Region","text":"","category":"section"},{"location":"IR/region/","page":"Region","title":"Region","text":"Modules = [MLIR.IR]\nPages = [\"IR/Region.jl\"]","category":"page"},{"location":"IR/region/#MLIR.IR.Region-Tuple{}","page":"Region","title":"MLIR.IR.Region","text":"Region()\n\nCreates a new empty region and transfers ownership to the caller.\n\n\n\n\n\n","category":"method"},{"location":"IR/region/#Base.:==-Tuple{MLIR.IR.Region, MLIR.IR.Region}","page":"Region","title":"Base.:==","text":"==(region, other)\n\nChecks whether two region handles point to the same region. This does not perform deep comparison.\n\n\n\n\n\n","category":"method"},{"location":"IR/region/#Base.insert!-Tuple{MLIR.IR.Region, Any, MLIR.IR.Block}","page":"Region","title":"Base.insert!","text":"insert!(region, index, block)\n\nTakes a block owned by the caller and inserts it at index to the given region. This is an expensive operation that linearly scans the region, prefer insertAfter/Before instead.\n\n\n\n\n\n","category":"method"},{"location":"IR/region/#Base.push!-Tuple{MLIR.IR.Region, MLIR.IR.Block}","page":"Region","title":"Base.push!","text":"push!(region, block)\n\nTakes a block owned by the caller and appends it to the given region.\n\n\n\n\n\n","category":"method"},{"location":"IR/region/#MLIR.IR.first_block-Tuple{MLIR.IR.Region}","page":"Region","title":"MLIR.IR.first_block","text":"first_block(region)\n\nGets the first block in the region.\n\n\n\n\n\n","category":"method"},{"location":"IR/region/#MLIR.IR.insert_after!-Tuple{MLIR.IR.Region, MLIR.IR.Block, MLIR.IR.Block}","page":"Region","title":"MLIR.IR.insert_after!","text":"insert_after!(region, reference, block)\n\nTakes a block owned by the caller and inserts it after the (non-owned) reference block in the given region. The reference block must belong to the region. If the reference block is null, prepends the block to the region.\n\n\n\n\n\n","category":"method"},{"location":"IR/region/#MLIR.IR.insert_before!-Tuple{MLIR.IR.Region, MLIR.IR.Block, MLIR.IR.Block}","page":"Region","title":"MLIR.IR.insert_before!","text":"insert_before!(region, reference, block)\n\nTakes a block owned by the caller and inserts it before the (non-owned) reference block in the given region. The reference block must belong to the region. If the reference block is null, appends the block to the region.\n\n\n\n\n\n","category":"method"},{"location":"dialects/complex/#complex-dialect","page":"complex","title":"complex dialect","text":"","category":"section"},{"location":"dialects/complex/","page":"complex","title":"complex","text":"Modules = [MLIR.Dialects.complex]\nPages = [\"Dialects/15/Complex.jl\"]","category":"page"},{"location":"dialects/memref/#memref-dialect","page":"memref","title":"memref dialect","text":"","category":"section"},{"location":"dialects/memref/","page":"memref","title":"memref","text":"Modules = [MLIR.Dialects.memref]\nPages = [\"Dialects/15/MemRef.jl\"]","category":"page"},{"location":"dialects/llvm/#llvm-dialect","page":"llvm","title":"llvm dialect","text":"","category":"section"},{"location":"dialects/llvm/","page":"llvm","title":"llvm","text":"Modules = [MLIR.Dialects.llvm]\nPages = [\"Dialects/15/LLVMIR.jl\"]","category":"page"},{"location":"IR/identifier/#Identifier","page":"Identifier","title":"Identifier","text":"","category":"section"},{"location":"IR/identifier/","page":"Identifier","title":"Identifier","text":"Modules = [MLIR.IR]\nPages = [\"IR/Identifier.jl\"]","category":"page"},{"location":"IR/identifier/#Core.String-Tuple{MLIR.IR.Identifier}","page":"Identifier","title":"Core.String","text":"String(ident)\n\nGets the string value of the identifier.\n\n\n\n\n\n","category":"method"},{"location":"IR/identifier/#MLIR.IR.Identifier-Tuple{String}","page":"Identifier","title":"MLIR.IR.Identifier","text":"Identifier(context, str)\n\nGets an identifier with the given string value.\n\n\n\n\n\n","category":"method"},{"location":"IR/identifier/#Base.:==-Tuple{MLIR.IR.Identifier, MLIR.IR.Identifier}","page":"Identifier","title":"Base.:==","text":"==(ident, other)\n\nChecks whether two identifiers are the same.\n\n\n\n\n\n","category":"method"},{"location":"IR/identifier/#MLIR.IR.context-Tuple{MLIR.IR.Identifier}","page":"Identifier","title":"MLIR.IR.context","text":"context(ident)\n\nReturns the context associated with this identifier\n\n\n\n\n\n","category":"method"},{"location":"dialects/affine/#affine-dialect","page":"affine","title":"affine dialect","text":"","category":"section"},{"location":"dialects/affine/","page":"affine","title":"affine","text":"Modules = [MLIR.Dialects.affine]\nPages = [\"Dialects/15/Affine.jl\"]","category":"page"},{"location":"dialects/arm_neon/#arm_neon-dialect","page":"arm_neon","title":"arm_neon dialect","text":"","category":"section"},{"location":"dialects/arm_neon/","page":"arm_neon","title":"arm_neon","text":"Modules = [MLIR.Dialects.arm_neon]\nPages = [\"Dialects/15/ArmNeon.jl\"]","category":"page"},{"location":"dialects/transform/#transform-dialect","page":"transforms","title":"transform dialect","text":"","category":"section"},{"location":"dialects/transform/","page":"transforms","title":"transforms","text":"Modules = [MLIR.Dialects.transform]\nPages = [\"Dialects/15/Transform.jl\"]","category":"page"},{"location":"IR/type/#Type","page":"Type","title":"Type","text":"","category":"section"},{"location":"IR/type/","page":"Type","title":"Type","text":"Modules = [MLIR.IR]\nPages = [\"IR/Type.jl\"]","category":"page"},{"location":"IR/type/#MLIR.IR.Type-Tuple{Type{<:Integer}}","page":"Type","title":"MLIR.IR.Type","text":"Type(T::Core.Type{<:Integer}; context=context()\n\nCreates a signless integer type of the given bitwidth in the context. The type is owned by the context.\n\n\n\n\n\n","category":"method"},{"location":"IR/type/#MLIR.IR.Type-Tuple{Type{<:Signed}}","page":"Type","title":"MLIR.IR.Type","text":"Type(T::Core.Type{<:Signed}; context=context()\n\nCreates a signed integer type of the given bitwidth in the context. The type is owned by the context.\n\n\n\n\n\n","category":"method"},{"location":"IR/type/#MLIR.IR.Type-Tuple{Type{<:Unsigned}}","page":"Type","title":"MLIR.IR.Type","text":"Type(T::Core.Type{<:Unsigned}; context=context()\n\nCreates an unsigned integer type of the given bitwidth in the context. The type is owned by the context.\n\n\n\n\n\n","category":"method"},{"location":"IR/type/#MLIR.IR.Type-Tuple{Type{Bool}}","page":"Type","title":"MLIR.IR.Type","text":"Type(T::Core.Type{Bool}; context=context()\n\nCreates a 1-bit signless integer type in the context. The type is owned by the context.\n\n\n\n\n\n","category":"method"},{"location":"IR/type/#MLIR.IR.Type-Tuple{Type{Float16}}","page":"Type","title":"MLIR.IR.Type","text":"Type(::Core.Type{Float16}; context=context())\n\nCreates an f16 type in the given context. The type is owned by the context.\n\n\n\n\n\n","category":"method"},{"location":"IR/type/#MLIR.IR.Type-Tuple{Type{Float32}}","page":"Type","title":"MLIR.IR.Type","text":"Type(Core.Type{Float32}; context=context())\n\nCreates an f32 type in the given context. The type is owned by the context.\n\n\n\n\n\n","category":"method"},{"location":"IR/type/#MLIR.IR.Type-Tuple{Type{Float64}}","page":"Type","title":"MLIR.IR.Type","text":"Type(Core.Type{Float64}; context=context())\n\nCreates a f64 type in the given context. The type is owned by the context.\n\n\n\n\n\n","category":"method"},{"location":"IR/type/#MLIR.IR.Type-Tuple{Type{Nothing}}","page":"Type","title":"MLIR.IR.Type","text":"Type(::Core.Type{Nothing}; context=context())\n\nCreates a None type in the given context. The type is owned by the context.\n\n\n\n\n\n","category":"method"},{"location":"IR/type/#MLIR.IR.Type-Tuple{Vector{MLIR.IR.Type}}","page":"Type","title":"MLIR.IR.Type","text":"Type(elements; context=context())\nType(::Core.Type{<:Tuple{T...}}; context=context())\n\nCreates a tuple type that consists of the given list of elemental types. The type is owned by the context.\n\n\n\n\n\n","category":"method"},{"location":"IR/type/#MLIR.IR.Type-Union{Tuple{Type{Complex{T}}}, Tuple{T}} where T","page":"Type","title":"MLIR.IR.Type","text":"Type(Complex{T}) where {T}\n\nCreates a complex type with the given element type in the same context as the element type. The type is owned by the context.\n\n\n\n\n\n","category":"method"},{"location":"IR/type/#Base.:==-Tuple{MLIR.IR.Type, MLIR.IR.Type}","page":"Type","title":"Base.:==","text":"==(t1, t2)\n\nChecks if two types are equal.\n\n\n\n\n\n","category":"method"},{"location":"IR/type/#Base.ndims-Tuple{MLIR.IR.Type}","page":"Type","title":"Base.ndims","text":"ndims(type)\n\nReturns the rank of the given ranked shaped type.\n\n\n\n\n\n","category":"method"},{"location":"IR/type/#Base.parse-Tuple{Type{MLIR.IR.Type}, Any}","page":"Type","title":"Base.parse","text":"parse(type; context=context())\n\nParses a type. The type is owned by the context.\n\n\n\n\n\n","category":"method"},{"location":"IR/type/#Base.size-Tuple{MLIR.IR.Type, Int64}","page":"Type","title":"Base.size","text":"size(type, i)\n\nReturns the i-th dimension of the given ranked shaped type.\n\n\n\n\n\n","category":"method"},{"location":"IR/type/#MLIR.IR.BFloat16Type-Tuple{}","page":"Type","title":"MLIR.IR.BFloat16Type","text":"BFloat16Type(; context=context())\n\nCreates a bf16 type in the given context. The type is owned by the context.\n\n\n\n\n\n","category":"method"},{"location":"IR/type/#MLIR.IR.Float8E4M3FN-Tuple{}","page":"Type","title":"MLIR.IR.Float8E4M3FN","text":"Float8E4M3FN(; context=context())\n\nCreates an f8E4M3FN type in the given context. The type is owned by the context.\n\n\n\n\n\n","category":"method"},{"location":"IR/type/#MLIR.IR.Float8E5M2-Tuple{}","page":"Type","title":"MLIR.IR.Float8E5M2","text":"Float8E5M2(; context=context())\n\nCreates an f8E5M2 type in the given context. The type is owned by the context.\n\n\n\n\n\n","category":"method"},{"location":"IR/type/#MLIR.IR.FunctionType-Tuple{Any, Any}","page":"Type","title":"MLIR.IR.FunctionType","text":"FunctionType(inputs, results; context=context())\n\nCreates a function type, mapping a list of input types to result types.\n\n\n\n\n\n","category":"method"},{"location":"IR/type/#MLIR.IR.IndexType-Tuple{}","page":"Type","title":"MLIR.IR.IndexType","text":"IndexType(; context=context())\n\nCreates an index type in the given context. The type is owned by the context.\n\n\n\n\n\n","category":"method"},{"location":"IR/type/#MLIR.IR.MemRefType-Tuple{MLIR.IR.Type, Any, Any, Any}","page":"Type","title":"MLIR.IR.MemRefType","text":"MemRefType(elementType, rank, shape, layout, memorySpace; location=Location(), check=false)\n\nCreates a MemRef type with the given rank and shape, a potentially empty list of affine layout maps, the given memory space and element type, in the same context as element type. The type is owned by the context. If check=true, emits appropriate diagnostics on illegal arguments.\n\n\n\n\n\n","category":"method"},{"location":"IR/type/#MLIR.IR.MemRefType-Tuple{MLIR.IR.Type, Any, Any}","page":"Type","title":"MLIR.IR.MemRefType","text":"MemRefType(elementType, rank, shape, memorySpace; location=Location(), check=false)\n\nCreates a MemRef type with the given rank, shape, memory space and element type in the same context as the element type. The type has no affine maps, i.e. represents a default row-major contiguous memref. The type is owned by the context. If check=true, emits appropriate diagnostics on illegal arguments.\n\n\n\n\n\n","category":"method"},{"location":"IR/type/#MLIR.IR.MemRefType-Tuple{MLIR.IR.Type, Any}","page":"Type","title":"MLIR.IR.MemRefType","text":"MemRefType(elementType, memorySpace)\n\nCreates an Unranked MemRef type with the given element type and in the given memory space. The type is owned by the context of element type. If check=true, emits appropriate diagnostics on illegal arguments.\n\n\n\n\n\n","category":"method"},{"location":"IR/type/#MLIR.IR.OpaqueType-Tuple{Any, Any}","page":"Type","title":"MLIR.IR.OpaqueType","text":"OpaqueType(dialectNamespace, typeData; context=context())\n\nCreates an opaque type in the given context associated with the dialect identified by its namespace. The type contains opaque byte data of the specified length (data need not be null-terminated).\n\n\n\n\n\n","category":"method"},{"location":"IR/type/#MLIR.IR.TensorType","page":"Type","title":"MLIR.IR.TensorType","text":"TensorType(shape, elementType, encoding=Attribute(); location=Location(), check=false)\n\nCreates a tensor type of a fixed rank with the given shape, element type, and optional encoding in the same context as the element type. The type is owned by the context. Tensor types without any specific encoding field should assign mlirAttributeGetNull to this parameter. If check=true, emits appropriate diagnostics on illegal arguments.\n\n\n\n\n\n","category":"function"},{"location":"IR/type/#MLIR.IR.TensorType-Tuple{Any}","page":"Type","title":"MLIR.IR.TensorType","text":"TensorType(elementType)\n\nCreates an unranked tensor type with the given element type in the same context as the element type. The type is owned by the context. If check=true, emits appropriate diagnostics on illegal arguments.\n\n\n\n\n\n","category":"method"},{"location":"IR/type/#MLIR.IR.VectorType-Tuple{Any, Any, Any}","page":"Type","title":"MLIR.IR.VectorType","text":"VectorType(rank, shape, elementType; location=Location(), check=false)\n\nCreates a vector type of the shape identified by its rank and dimensions, with the given element type in the same context as the element type. The type is owned by the context. If check=true, emits appropriate diagnostics on illegal arguments.\n\n\n\n\n\n","category":"method"},{"location":"IR/type/#MLIR.IR.affinemap-Tuple{MLIR.IR.Type}","page":"Type","title":"MLIR.IR.affinemap","text":"affinemap(type)\n\nReturns the affine map of the given MemRef type.\n\n\n\n\n\n","category":"method"},{"location":"IR/type/#MLIR.IR.bitwidth-Tuple{MLIR.IR.Type}","page":"Type","title":"MLIR.IR.bitwidth","text":"bitwidth(type)\n\nReturns the bitwidth of an integer type.\n\n\n\n\n\n","category":"method"},{"location":"IR/type/#MLIR.IR.context-Tuple{MLIR.IR.Type}","page":"Type","title":"MLIR.IR.context","text":"context(type)\n\nGets the context that a type was created with.\n\n\n\n\n\n","category":"method"},{"location":"IR/type/#MLIR.IR.data-Tuple{MLIR.IR.Type}","page":"Type","title":"MLIR.IR.data","text":"mlirOpaqueTypeGetData(type)\n\nReturns the raw data as a string reference. The data remains live as long as the context in which the type lives.\n\n\n\n\n\n","category":"method"},{"location":"IR/type/#MLIR.IR.dynsize-Tuple{}","page":"Type","title":"MLIR.IR.dynsize","text":"dynsize()\n\nReturns the value indicating a dynamic size in a shaped type. Prefer isdynsize to direct comparisons with this value.\n\n\n\n\n\n","category":"method"},{"location":"IR/type/#MLIR.IR.dynstrideoroffset-Tuple{}","page":"Type","title":"MLIR.IR.dynstrideoroffset","text":"mlirShapedTypeGetDynamicStrideOrOffset()\n\nReturns the value indicating a dynamic stride or offset in a shaped type. Prefer isdynstrideoroffset to direct comparisons with this value.\n\n\n\n\n\n","category":"method"},{"location":"IR/type/#MLIR.IR.encoding-Tuple{MLIR.IR.Type}","page":"Type","title":"MLIR.IR.encoding","text":"encoding(type)\n\nGets the 'encoding' attribute from the ranked tensor type, returning a nothing if none.\n\n\n\n\n\n","category":"method"},{"location":"IR/type/#MLIR.IR.hasrank-Tuple{MLIR.IR.Type}","page":"Type","title":"MLIR.IR.hasrank","text":"hasrank(type)\n\nChecks whether the given shaped type is ranked.\n\n\n\n\n\n","category":"method"},{"location":"IR/type/#MLIR.IR.hasstaticshape-Tuple{MLIR.IR.Type}","page":"Type","title":"MLIR.IR.hasstaticshape","text":"hasstaticshape(type)\n\nChecks whether the given shaped type has a static shape.\n\n\n\n\n\n","category":"method"},{"location":"IR/type/#MLIR.IR.input-Tuple{MLIR.IR.Type, Any}","page":"Type","title":"MLIR.IR.input","text":"input(type, i)\n\nReturns the i-th input type.\n\n\n\n\n\n","category":"method"},{"location":"IR/type/#MLIR.IR.isbf16-Tuple{MLIR.IR.Type}","page":"Type","title":"MLIR.IR.isbf16","text":"isbf16(type)\n\nChecks whether the given type is a bf16 type.\n\n\n\n\n\n","category":"method"},{"location":"IR/type/#MLIR.IR.iscomplex-Tuple{MLIR.IR.Type}","page":"Type","title":"MLIR.IR.iscomplex","text":"iscomplex(type)\n\nChecks whether the given type is a Complex type.\n\n\n\n\n\n","category":"method"},{"location":"IR/type/#MLIR.IR.isdyndim-Tuple{MLIR.IR.Type, Int64}","page":"Type","title":"MLIR.IR.isdyndim","text":"isdyndim(type, i)\n\nChecks wither the i-th dimension of the given shaped type is dynamic.\n\n\n\n\n\n","category":"method"},{"location":"IR/type/#MLIR.IR.isdynsize-Tuple{Any}","page":"Type","title":"MLIR.IR.isdynsize","text":"isdynsize(size)\n\nChecks whether the given value is used as a placeholder for dynamic sizes in shaped types.\n\n\n\n\n\n","category":"method"},{"location":"IR/type/#MLIR.IR.isdynstrideoroffset-Tuple{Any}","page":"Type","title":"MLIR.IR.isdynstrideoroffset","text":"mlirShapedTypeIsDynamicStrideOrOffset(val)\n\nChecks whether the given value is used as a placeholder for dynamic strides and offsets in shaped types.\n\n\n\n\n\n","category":"method"},{"location":"IR/type/#MLIR.IR.isf16-Tuple{MLIR.IR.Type}","page":"Type","title":"MLIR.IR.isf16","text":"isf16(type)\n\nChecks whether the given type is an f16 type.\n\n\n\n\n\n","category":"method"},{"location":"IR/type/#MLIR.IR.isf32-Tuple{MLIR.IR.Type}","page":"Type","title":"MLIR.IR.isf32","text":"isf32(type)\n\nChecks whether the given type is an f32 type.\n\n\n\n\n\n","category":"method"},{"location":"IR/type/#MLIR.IR.isf64-Tuple{MLIR.IR.Type}","page":"Type","title":"MLIR.IR.isf64","text":"isf64(type)\n\nChecks whether the given type is an f64 type.\n\n\n\n\n\n","category":"method"},{"location":"IR/type/#MLIR.IR.isf8e4m3fn-Tuple{MLIR.IR.Type}","page":"Type","title":"MLIR.IR.isf8e4m3fn","text":"isf8e4m3fn(type)\n\nChecks whether the given type is an f8E4M3FN type.\n\n\n\n\n\n","category":"method"},{"location":"IR/type/#MLIR.IR.isf8e5m2-Tuple{MLIR.IR.Type}","page":"Type","title":"MLIR.IR.isf8e5m2","text":"isf8e5m2(type)\n\nChecks whether the given type is an f8E5M2 type.\n\n\n\n\n\n","category":"method"},{"location":"IR/type/#MLIR.IR.isfunction-Tuple{MLIR.IR.Type}","page":"Type","title":"MLIR.IR.isfunction","text":"isfunction(type)\n\nChecks whether the given type is a function type.\n\n\n\n\n\n","category":"method"},{"location":"IR/type/#MLIR.IR.isindex-Tuple{MLIR.IR.Type}","page":"Type","title":"MLIR.IR.isindex","text":"isindex(type)\n\nChecks whether the given type is an index type.\n\n\n\n\n\n","category":"method"},{"location":"IR/type/#MLIR.IR.isinteger-Tuple{MLIR.IR.Type}","page":"Type","title":"MLIR.IR.isinteger","text":"isinteger(type)\n\nChecks whether the given type is an integer type.\n\n\n\n\n\n","category":"method"},{"location":"IR/type/#MLIR.IR.ismemref-Tuple{MLIR.IR.Type}","page":"Type","title":"MLIR.IR.ismemref","text":"ismemref(type)\n\nChecks whether the given type is a MemRef type.\n\n\n\n\n\n","category":"method"},{"location":"IR/type/#MLIR.IR.isnone-Tuple{MLIR.IR.Type}","page":"Type","title":"MLIR.IR.isnone","text":"mlirTypeIsANone(type)\n\nChecks whether the given type is a None type.\n\n\n\n\n\n","category":"method"},{"location":"IR/type/#MLIR.IR.isopaque-Tuple{MLIR.IR.Type}","page":"Type","title":"MLIR.IR.isopaque","text":"isopaque(type)\n\nChecks whether the given type is an opaque type.\n\n\n\n\n\n","category":"method"},{"location":"IR/type/#MLIR.IR.isrankedtensor-Tuple{MLIR.IR.Type}","page":"Type","title":"MLIR.IR.isrankedtensor","text":"isrankedtensor(type)\n\nChecks whether the given type is a ranked tensor type.\n\n\n\n\n\n","category":"method"},{"location":"IR/type/#MLIR.IR.isshaped-Tuple{MLIR.IR.Type}","page":"Type","title":"MLIR.IR.isshaped","text":"isshaped(type)\n\nChecks whether the given type is a Shaped type.\n\n\n\n\n\n","category":"method"},{"location":"IR/type/#MLIR.IR.issigned-Tuple{MLIR.IR.Type}","page":"Type","title":"MLIR.IR.issigned","text":"issigned(type)\n\nChecks whether the given integer type is signed.\n\n\n\n\n\n","category":"method"},{"location":"IR/type/#MLIR.IR.issignless-Tuple{MLIR.IR.Type}","page":"Type","title":"MLIR.IR.issignless","text":"issignless(type)\n\nChecks whether the given integer type is signless.\n\n\n\n\n\n","category":"method"},{"location":"IR/type/#MLIR.IR.istensor-Tuple{MLIR.IR.Type}","page":"Type","title":"MLIR.IR.istensor","text":"istensor(type)\n\nChecks whether the given type is a Tensor type.\n\n\n\n\n\n","category":"method"},{"location":"IR/type/#MLIR.IR.istuple-Tuple{MLIR.IR.Type}","page":"Type","title":"MLIR.IR.istuple","text":"istuple(type)\n\nChecks whether the given type is a tuple type.\n\n\n\n\n\n","category":"method"},{"location":"IR/type/#MLIR.IR.isunrankedmemref-Tuple{MLIR.IR.Type}","page":"Type","title":"MLIR.IR.isunrankedmemref","text":"mlirTypeIsAUnrankedMemRef(type)\n\nChecks whether the given type is an UnrankedMemRef type.\n\n\n\n\n\n","category":"method"},{"location":"IR/type/#MLIR.IR.isunrankedtensor-Tuple{MLIR.IR.Type}","page":"Type","title":"MLIR.IR.isunrankedtensor","text":"isunrankedtensor(type)\n\nChecks whether the given type is an unranked tensor type.\n\n\n\n\n\n","category":"method"},{"location":"IR/type/#MLIR.IR.isunsigned-Tuple{MLIR.IR.Type}","page":"Type","title":"MLIR.IR.isunsigned","text":"isunsigned(type)\n\nChecks whether the given integer type is unsigned.\n\n\n\n\n\n","category":"method"},{"location":"IR/type/#MLIR.IR.isvector-Tuple{MLIR.IR.Type}","page":"Type","title":"MLIR.IR.isvector","text":"isvector(type)\n\nChecks whether the given type is a Vector type.\n\n\n\n\n\n","category":"method"},{"location":"IR/type/#MLIR.IR.layout-Tuple{MLIR.IR.Type}","page":"Type","title":"MLIR.IR.layout","text":"layout(type)\n\nReturns the layout of the given MemRef type.\n\n\n\n\n\n","category":"method"},{"location":"IR/type/#MLIR.IR.memspace-Tuple{MLIR.IR.Type}","page":"Type","title":"MLIR.IR.memspace","text":"mlirMemRefTypeGetMemorySpace(type)\n\nReturns the memory space of the given MemRef type.\n\n\n\n\n\n","category":"method"},{"location":"IR/type/#MLIR.IR.namespace-Tuple{MLIR.IR.Type}","page":"Type","title":"MLIR.IR.namespace","text":"mlirOpaqueTypeGetDialectNamespace(type)\n\nReturns the namespace of the dialect with which the given opaque type is associated. The namespace string is owned by the context.\n\n\n\n\n\n","category":"method"},{"location":"IR/type/#MLIR.IR.ninputs-Tuple{MLIR.IR.Type}","page":"Type","title":"MLIR.IR.ninputs","text":"ninputs(type)\n\nReturns the number of input types.\n\n\n\n\n\n","category":"method"},{"location":"IR/type/#MLIR.IR.nresults-Tuple{MLIR.IR.Type}","page":"Type","title":"MLIR.IR.nresults","text":"nresults(type)\n\nReturns the number of result types.\n\n\n\n\n\n","category":"method"},{"location":"IR/type/#MLIR.IR.result","page":"Type","title":"MLIR.IR.result","text":"result(type, i)\n\nReturns the i-th result type.\n\n\n\n\n\n","category":"function"},{"location":"IR/type/#MLIR.IR.typeid-Tuple{MLIR.IR.Type}","page":"Type","title":"MLIR.IR.typeid","text":"typeid(type)\n\nGets the type ID of the type.\n\n\n\n\n\n","category":"method"},{"location":"dialects/sparse_tensor/#sparse_tensor-dialect","page":"sparse_tensor","title":"sparse_tensor dialect","text":"","category":"section"},{"location":"dialects/sparse_tensor/","page":"sparse_tensor","title":"sparse_tensor","text":"Modules = [MLIR.Dialects.sparse_tensor]\nPages = [\"Dialects/15/SparseTensor.jl\"]","category":"page"},{"location":"dialects/vector/#vector-dialect","page":"vector","title":"vector dialect","text":"","category":"section"},{"location":"dialects/vector/","page":"vector","title":"vector","text":"Modules = [MLIR.Dialects.vector]\nPages = [\"Dialects/15/Vector.jl\"]","category":"page"},{"location":"IR/affineexpr/#Affine-Expressions","page":"AffineExpr","title":"Affine Expressions","text":"","category":"section"},{"location":"IR/affineexpr/","page":"AffineExpr","title":"AffineExpr","text":"Modules = [MLIR.IR]\nPages = [\"IR/AffineExpr.jl\"]","category":"page"},{"location":"IR/affineexpr/#Base.:*-Tuple{MLIR.IR.AffineExpr, MLIR.IR.AffineExpr}","page":"AffineExpr","title":"Base.:*","text":"*(lhs, rhs)\n\nCreates an affine mul expression with 'lhs' and 'rhs'.\n\n\n\n\n\n","category":"method"},{"location":"IR/affineexpr/#Base.:+-Tuple{MLIR.IR.AffineExpr, MLIR.IR.AffineExpr}","page":"AffineExpr","title":"Base.:+","text":"+(lhs, rhs)\n\nCreates an affine add expression with 'lhs' and 'rhs'.\n\n\n\n\n\n","category":"method"},{"location":"IR/affineexpr/#Base.:==-Tuple{MLIR.IR.AffineExpr, MLIR.IR.AffineExpr}","page":"AffineExpr","title":"Base.:==","text":"==(a, b)\n\nReturns true if the two affine expressions are equal.\n\n\n\n\n\n","category":"method"},{"location":"IR/affineexpr/#Base.cld-Tuple{MLIR.IR.AffineExpr, MLIR.IR.AffineExpr}","page":"AffineExpr","title":"Base.cld","text":"cld(lhs, rhs)\n\nCreates an affine ceildiv expression with 'lhs' and 'rhs'.\n\n\n\n\n\n","category":"method"},{"location":"IR/affineexpr/#Base.div-Tuple{MLIR.IR.AffineExpr, MLIR.IR.AffineExpr}","page":"AffineExpr","title":"Base.div","text":"div(lhs, rhs)\n÷(lhs, rhs)\nfld(lhs, rhs)\n\nCreates an affine floordiv expression with 'lhs' and 'rhs'.\n\n\n\n\n\n","category":"method"},{"location":"IR/affineexpr/#Base.gcd-Tuple{MLIR.IR.AffineExpr}","page":"AffineExpr","title":"Base.gcd","text":"gcd(affineExpr)\n\nReturns the greatest known integral divisor of this affine expression. The result is always positive.\n\n\n\n\n\n","category":"method"},{"location":"IR/affineexpr/#Base.mod-Tuple{MLIR.IR.AffineExpr, MLIR.IR.AffineExpr}","page":"AffineExpr","title":"Base.mod","text":"mod(lhs, rhs)\n\nCreates an affine mod expression with 'lhs' and 'rhs'.\n\n\n\n\n\n","category":"method"},{"location":"IR/affineexpr/#MLIR.IR.AffineDimensionExpr-Tuple{Any}","page":"AffineExpr","title":"MLIR.IR.AffineDimensionExpr","text":"AffineDimensionExpr(position; context=context)\n\nCreates an affine dimension expression with 'position' in the context.\n\n\n\n\n\n","category":"method"},{"location":"IR/affineexpr/#MLIR.IR.ConstantExpr-Tuple{Any}","page":"AffineExpr","title":"MLIR.IR.ConstantExpr","text":"ConstantExpr(constant::Int; context=context())\n\nCreates an affine constant expression with 'constant' in the context.\n\n\n\n\n\n","category":"method"},{"location":"IR/affineexpr/#MLIR.IR.SymbolExpr-Tuple{Any}","page":"AffineExpr","title":"MLIR.IR.SymbolExpr","text":"SymbolExpr(position; context=context())\n\nCreates an affine symbol expression with 'position' in the context.\n\n\n\n\n\n","category":"method"},{"location":"IR/affineexpr/#MLIR.IR.context-Tuple{MLIR.IR.AffineExpr}","page":"AffineExpr","title":"MLIR.IR.context","text":"context(affineExpr)\n\nGets the context that owns the affine expression.\n\n\n\n\n\n","category":"method"},{"location":"IR/affineexpr/#MLIR.IR.is_pure_affine-Tuple{MLIR.IR.AffineExpr}","page":"AffineExpr","title":"MLIR.IR.is_pure_affine","text":"is_pure_affine(affineExpr)\n\nChecks whether the given affine expression is a pure affine expression, i.e. mul, floordiv, ceildic, and mod is only allowed w.r.t constants.\n\n\n\n\n\n","category":"method"},{"location":"IR/affineexpr/#MLIR.IR.is_symbolic_or_constant-Tuple{MLIR.IR.AffineExpr}","page":"AffineExpr","title":"MLIR.IR.is_symbolic_or_constant","text":"is_symbolic_or_constant(affineExpr)\n\nChecks whether the given affine expression is made out of only symbols and constants.\n\n\n\n\n\n","category":"method"},{"location":"IR/affineexpr/#MLIR.IR.isadd-Tuple{MLIR.IR.AffineExpr}","page":"AffineExpr","title":"MLIR.IR.isadd","text":"isadd(affineExpr)\n\nChecks whether the given affine expression is an add expression.\n\n\n\n\n\n","category":"method"},{"location":"IR/affineexpr/#MLIR.IR.isbinary-Tuple{MLIR.IR.AffineExpr}","page":"AffineExpr","title":"MLIR.IR.isbinary","text":"isbinary(affineExpr)\n\nChecks whether the given affine expression is binary.\n\n\n\n\n\n","category":"method"},{"location":"IR/affineexpr/#MLIR.IR.isceildiv-Tuple{MLIR.IR.AffineExpr}","page":"AffineExpr","title":"MLIR.IR.isceildiv","text":"isceildiv(affineExpr)\n\nChecks whether the given affine expression is an ceildiv expression.\n\n\n\n\n\n","category":"method"},{"location":"IR/affineexpr/#MLIR.IR.isconstantexpr-Tuple{MLIR.IR.AffineExpr}","page":"AffineExpr","title":"MLIR.IR.isconstantexpr","text":"isconstantexpr(affineExpr)\n\nChecks whether the given affine expression is a constant expression.\n\n\n\n\n\n","category":"method"},{"location":"IR/affineexpr/#MLIR.IR.isdimexpr-Tuple{MLIR.IR.AffineExpr}","page":"AffineExpr","title":"MLIR.IR.isdimexpr","text":"isdimexpr(affineExpr)\n\nChecks whether the given affine expression is a dimension expression.\n\n\n\n\n\n","category":"method"},{"location":"IR/affineexpr/#MLIR.IR.isfloordiv-Tuple{MLIR.IR.AffineExpr}","page":"AffineExpr","title":"MLIR.IR.isfloordiv","text":"isfloordiv(affineExpr)\n\nChecks whether the given affine expression is an floordiv expression.\n\n\n\n\n\n","category":"method"},{"location":"IR/affineexpr/#MLIR.IR.isfunctionofdimexpr-Tuple{MLIR.IR.AffineExpr, Any}","page":"AffineExpr","title":"MLIR.IR.isfunctionofdimexpr","text":"isfunctionofdimexpr(affineExpr, position)\n\nChecks whether the given affine expression involves AffineDimExpr 'position'.\n\n\n\n\n\n","category":"method"},{"location":"IR/affineexpr/#MLIR.IR.ismod-Tuple{MLIR.IR.AffineExpr}","page":"AffineExpr","title":"MLIR.IR.ismod","text":"ismod(affineExpr)\n\nChecks whether the given affine expression is an mod expression.\n\n\n\n\n\n","category":"method"},{"location":"IR/affineexpr/#MLIR.IR.ismul-Tuple{MLIR.IR.AffineExpr}","page":"AffineExpr","title":"MLIR.IR.ismul","text":"ismul(affineExpr)\n\nChecks whether the given affine expression is an mul expression.\n\n\n\n\n\n","category":"method"},{"location":"IR/affineexpr/#MLIR.IR.ismultipleof-Tuple{MLIR.IR.AffineExpr, Any}","page":"AffineExpr","title":"MLIR.IR.ismultipleof","text":"ismultipleof(affineExpr, factor)\n\nChecks whether the given affine expression is a multiple of 'factor'.\n\n\n\n\n\n","category":"method"},{"location":"IR/affineexpr/#MLIR.IR.issymbolexpr-Tuple{MLIR.IR.AffineExpr}","page":"AffineExpr","title":"MLIR.IR.issymbolexpr","text":"issymbolexpr(affineExpr)\n\nChecks whether the given affine expression is a symbol expression.\n\n\n\n\n\n","category":"method"},{"location":"IR/affineexpr/#MLIR.IR.lhs-Tuple{MLIR.IR.AffineExpr}","page":"AffineExpr","title":"MLIR.IR.lhs","text":"lhs(affineExpr)\n\nReturns the left hand side affine expression of the given affine binary operation expression.\n\n\n\n\n\n","category":"method"},{"location":"IR/affineexpr/#MLIR.IR.position-Tuple{MLIR.IR.AffineExpr}","page":"AffineExpr","title":"MLIR.IR.position","text":"position(affineExpr)\n\nReturns the position of the given affine dimension expression, affine symbol expression or ...\n\n\n\n\n\n","category":"method"},{"location":"IR/affineexpr/#MLIR.IR.rhs-Tuple{MLIR.IR.AffineExpr}","page":"AffineExpr","title":"MLIR.IR.rhs","text":"rhs(affineExpr)\n\nReturns the right hand side affine expression of the given affine binary operation expression.\n\n\n\n\n\n","category":"method"},{"location":"IR/affineexpr/#MLIR.IR.value-Tuple{MLIR.IR.AffineExpr}","page":"AffineExpr","title":"MLIR.IR.value","text":"value(affineExpr)\n\nReturns the value of the given affine constant expression.\n\n\n\n\n\n","category":"method"}]
}
